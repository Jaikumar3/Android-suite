#!/usr/bin/env python3
"""
Android Pentesting Automation Tool
Centralized class-based approach for Android pentesting automation
"""

import os
import sys
import shutil
import subprocess
import time
import json
import platform
import lzma
from pathlib import Path

try:
    import requests
except ImportError:
    requests = None

class AndroidPentester:
    
    def __init__(self, apk_path=None, app_name=None, device_id=None, adb_path=None):
        """Initialize AndroidPentester with optional parameters"""
        self.apk_path = apk_path
        self.app_name = app_name
        self.device_id = device_id
        self.adb_path = adb_path

    def run_apktool(self, apk_path=None, output_dir=None, extra_args=None):
        """Run apktool to decompile APK using class context. Returns (success: bool, stdout: str, stderr: str, message: str)"""
        apk_path = apk_path or self.apk_path
        apktool_cmd = "apktool.bat" if platform.system() == "Windows" else "apktool"
        apktool_path = shutil.which(apktool_cmd)
        
        if not apktool_path:
            return False, '', '', "[!] apktool not found in PATH. Please install it and ensure it's available."
        
        output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apktool_out"
        cmd = [apktool_path, "d", apk_path, "-o", output_dir, "-f"]
        if extra_args:
            cmd.extend(extra_args)
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] APK decompiled to: {output_dir}"
        except Exception as e:
            return False, '', str(e), f"[!] apktool failed: {e}"

    def run_apkleaks(self, apk_path=None, output_dir=None, extra_args=None):
        """Run APKLeaks on the APK using class context. Returns (success: bool, stdout: str, stderr: str, message: str)"""
        apk_path = apk_path or self.apk_path
        apkleaks_path = shutil.which("apkleaks")
        if not apkleaks_path:
            return False, '', '', "[!] apkleaks not found in PATH. Please install it (pip install apkleaks)."
        output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apkleaks_out"
        os.makedirs(output_dir, exist_ok=True)
        cmd = [apkleaks_path, "-f", apk_path, "-o", output_dir]
        if extra_args:
            cmd.extend(extra_args)
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] APKLeaks results saved to: {output_dir}"
        except Exception as e:
            return False, '', str(e), f"[!] apkleaks failed: {e}"

    def list_installed_packages(self, device_id=None):
        """
        List all installed package names on the connected Android device using class context.
        Args:
            device_id (str): Device ID (optional, uses self.device_id if not provided)
        Returns a tuple (success: bool, packages: list, message: str)
        """
        adb_path = self.adb_path or shutil.which("adb")
        if not adb_path:
            return False, [], "[!] ADB not found in PATH. Please install Android SDK Platform Tools."
        
        device_id = device_id or self.device_id
        
        # Check if device is connected
        try:
            # First check if any devices are connected
            devices_result = subprocess.run([adb_path, "devices"], capture_output=True, text=True, check=True)
            connected_devices = []
            for line in devices_result.stdout.split('\n')[1:]:
                if line.strip() and '\tdevice' in line:
                    connected_devices.append(line.split('\t')[0])
            
            if not connected_devices:
                return False, [], "[!] No Android devices connected. Please connect a device and enable USB debugging."
            
            # If no specific device ID provided, use the first connected device
            if not device_id:
                device_id = connected_devices[0]
            elif device_id not in connected_devices:
                return False, [], f"[!] Device '{device_id}' not found. Connected devices: {', '.join(connected_devices)}"
                
        except subprocess.CalledProcessError as e:
            return False, [], f"[!] Failed to check connected devices: {e}"
        
        # Build command to list packages
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["shell", "pm", "list", "packages"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=30)
            packages = [line.replace("package:", "").strip() for line in result.stdout.splitlines() if line.strip()]
            
            if not packages:
                return False, [], "[!] No packages found on device. Device might not be properly connected."
            
            return True, packages, f"[+] Found {len(packages)} installed packages on device {device_id}"
            
        except subprocess.TimeoutExpired:
            return False, [], "[!] Timeout while listing packages. Device might be unresponsive."
        except subprocess.CalledProcessError as e:
            return False, [], f"[!] Failed to list packages: {e}"
        except Exception as e:
            return False, [], f"[!] Unexpected error: {e}"

    def extract_app_data_directory(self, package, dest_dir, device_id=None, use_compression=False):
        """
        Extract the /data/data/<package> directory from the device using adb (root required).
        Args:
            package (str): Package name to extract
            dest_dir (str): Destination directory for extracted data
            device_id (str): Device ID (optional)
            use_compression (bool): Use tar compression for large data (faster transfer)
        Returns (success: bool, message: str)
        """
        adb_path = self.adb_path or shutil.which("adb")
        if not adb_path:
            return False, "[!] adb not found in PATH. Please install platform-tools and add to PATH."
        
        if not package:
            return False, "[!] No package name provided."
        
        os.makedirs(dest_dir, exist_ok=True)
        device_id = device_id or self.device_id
        
        # Try to restart ADB daemon as root first
        try:
            root_cmd = [adb_path]
            if device_id:
                root_cmd += ["-s", device_id]
            root_cmd += ["root"]
            
            root_result = subprocess.run(root_cmd, capture_output=True, text=True, timeout=15)
            if root_result.returncode == 0:
                # Wait a moment for adb to restart
                time.sleep(2)
                # ADB root successful, we can try direct access
                use_root_access = True
            else:
                # ADB root failed, fall back to su method
                use_root_access = False
        except Exception:
            use_root_access = False
        
        if use_root_access:
            if use_compression:
                # Use tar compression for faster transfer of large data
                print("[*] Using compression for faster transfer...")
                copy_cmd = [adb_path]
                if device_id:
                    copy_cmd += ["-s", device_id]
                copy_cmd += ["shell", f"tar -czf /sdcard/{package}.tar.gz -C /data/data {package}"]
            else:
                # Try direct access with adb root
                copy_cmd = [adb_path]
                if device_id:
                    copy_cmd += ["-s", device_id]
                copy_cmd += ["shell", f"cp -r /data/data/{package} /sdcard/"]
            
            # Check app data size first to warn about large extractions
            size_cmd = [adb_path]
            if device_id:
                size_cmd += ["-s", device_id]
            size_cmd += ["shell", f"du -sh /data/data/{package} 2>/dev/null || echo 'Size check failed'"]
            
            try:
                size_result = subprocess.run(size_cmd, capture_output=True, text=True, timeout=10)
                if size_result.returncode == 0 and "Size check failed" not in size_result.stdout:
                    size_info = size_result.stdout.strip().split()[0] if size_result.stdout.strip() else "Unknown"
                    print(f"[*] App data size: {size_info}")
                    if any(unit in size_info.upper() for unit in ['G', 'GB']) or \
                       (any(unit in size_info.upper() for unit in ['M', 'MB']) and 
                        any(char.isdigit() for char in size_info) and 
                        int(''.join(filter(str.isdigit, size_info))) > 100):
                        print("[!] WARNING: Large app data detected. This may take several minutes.")
                        if not use_compression:
                            print("[*] TIP: Use compression option for faster transfer of large data.")
            except:
                pass  # Continue anyway if size check fails
        else:
            # Fall back to su method - first check if device supports su
            check_cmd = [adb_path]
            if device_id:
                check_cmd += ["-s", device_id]
            check_cmd += ["shell", "su", "-c", "echo 'root test'"]
            
            try:
                root_check = subprocess.run(check_cmd, capture_output=True, text=True, timeout=10)
                if root_check.returncode != 0:
                    return False, "[!] ROOT ACCESS REQUIRED: This feature requires a rooted Android device.\n" \
                                "The /data/data/ directory is protected and can only be accessed with root privileges.\n" \
                                "Please root your device or use an emulator with root access."
            except subprocess.TimeoutExpired:
                return False, "[!] ROOT CHECK TIMEOUT: Unable to verify root access. Device may not be rooted."
            except Exception:
                pass  # Continue anyway, let the actual pull command determine the result
            
            # Use su method
            copy_cmd = [adb_path]
            if device_id:
                copy_cmd += ["-s", device_id]
            copy_cmd += ["shell", "su", "-c", f"cp -r /data/data/{package} /sdcard/"]
        
        try:
            print("[*] Copying app data from protected directory...")
            print("[*] Maximum operation time: 10 minutes (will be killed if exceeded)")
            # First copy to accessible location (10 minute timeout max)
            copy_result = self._run_with_extended_timeout(copy_cmd, "copy", 600)
            if copy_result.returncode != 0:
                # Check for specific permission errors
                error_output = copy_result.stderr + copy_result.stdout
                if "Permission denied" in error_output:
                    return False, "[!] PERMISSION DENIED: Root access required to extract app data.\n" \
                                "Solution options:\n" \
                                "1. Root your Android device\n" \
                                "2. Use a rooted emulator (like Android x86 with SuperSU)\n" \
                                "3. Use 'adb backup' for non-rooted devices (limited data)"
                elif "No such file or directory" in error_output:
                    return False, f"[!] Package '{package}' not found or has no data directory.\n" \
                                f"Make sure the package is installed and has created data files."
                else:
                    return False, f"[!] Failed to copy app data with root: {error_output}"
            
            print("[*] Pulling app data to local machine...")
            print("[*] Maximum operation time: 10 minutes (will be killed if exceeded)")
            # Now pull from accessible location
            pull_cmd = [adb_path]
            if device_id:
                pull_cmd += ["-s", device_id]
            
            if use_compression:
                pull_cmd += ["pull", f"/sdcard/{package}.tar.gz", dest_dir]
            else:
                pull_cmd += ["pull", f"/sdcard/{package}", dest_dir]
            
            pull_result = self._run_with_extended_timeout(pull_cmd, "pull", 600)
            
            print("[*] Cleaning up temporary files...")
            # Clean up temporary copy
            cleanup_cmd = [adb_path]
            if device_id:
                cleanup_cmd += ["-s", device_id]
            
            if use_compression:
                cleanup_cmd += ["shell", "rm", "-f", f"/sdcard/{package}.tar.gz"]
            else:
                cleanup_cmd += ["shell", "rm", "-rf", f"/sdcard/{package}"]
            subprocess.run(cleanup_cmd, capture_output=True, text=True)
            
            if pull_result.returncode == 0:
                if use_compression:
                    # Extract the tar.gz file locally
                    print("[*] Extracting compressed data...")
                    import tarfile
                    tar_path = os.path.join(dest_dir, f"{package}.tar.gz")
                    try:
                        with tarfile.open(tar_path, 'r:gz') as tar:
                            tar.extractall(dest_dir)
                        os.remove(tar_path)  # Remove the tar.gz file after extraction
                        return True, f"[+] App data for '{package}' extracted to {dest_dir}\n" \
                                   f"[+] Used 'adb root' with compression for faster transfer."
                    except Exception as e:
                        return False, f"[!] Failed to extract compressed data: {e}"
                else:
                    return True, f"[+] App data for '{package}' extracted to {dest_dir}\n" \
                               f"[+] Used 'adb root' to access protected data."
            else:
                return False, f"[!] Failed to pull app data from device: {pull_result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "[!] TIMEOUT: Data extraction operation was aborted after exceeding time limits.\n" \
                        "This indicates extremely large app data or system issues:\n" \
                        "1. App data is too large (>1GB) - consider extracting specific subdirectories\n" \
                        "2. Device storage is full or corrupted\n" \
                        "3. USB connection is unstable\n" \
                        "4. Device performance issues\n" \
                        "RECOMMENDATION: Use 'adb backup' for very large apps or try compression option."
        except Exception as e:
            return False, f"[!] Unexpected error during extraction: {e}"

    def get_pid_for_package(self, package_name=None):
        """Get PID for a running package using adb. Returns list of (pid, process_name) tuples."""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = self.device_id
        package_name = package_name or self.app_name
        
        if not adb_path:
            return []
        
        try:
            cmd = [adb_path]
            if device_id:
                cmd += ["-s", device_id]
            cmd += ["shell", "ps"]
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            matches = []
            
            for line in result.stdout.splitlines():
                if package_name in line:
                    parts = line.split()
                    if len(parts) > 1:
                        pid = parts[1]
                        proc_name = parts[-1]
                        matches.append((pid, proc_name))
            
            return matches
        except Exception:
            return []

    def get_process_list(self):
        """Get list of running processes"""
        if not self.adb_path or not self.device_id:
            return []
        
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps"
            ], capture_output=True, text=True, check=True)
            
            processes = []
            lines = result.stdout.strip().split('\n')[1:]  # Skip header
            
            for line in lines:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 9:
                        process_info = {
                            'pid': parts[1],
                            'name': ' '.join(parts[8:])
                        }
                        processes.append(process_info)
            
            return processes
        except Exception:
            return []

    def get_logcat(self, filter_tag=None, save_to_file=None, lines=200):
        """Fetch logcat output from the device. Optionally filter by tag and save to file."""
        if not self.adb_path or not self.device_id:
            return None
        
        cmd = [self.adb_path, "-s", self.device_id, "logcat", "-d", "-t", str(lines)]
        if filter_tag:
            cmd += [f"*:{filter_tag}"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            log_output = result.stdout
            
            if save_to_file:
                with open(save_to_file, "w", encoding="utf-8") as f:
                    f.write(log_output)
            
            return log_output
        except Exception:
            return None

    # ADB utility methods
    def adb_install_apk(self, apk_path, device_id=None):
        """Install APK via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["install", "-r", apk_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return "Success" in result.stdout
        except Exception:
            return False

    def adb_uninstall_apk(self, package_name, device_id=None):
        """Uninstall APK via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["uninstall", package_name]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return "Success" in result.stdout
        except Exception:
            return False

    def adb_push_file(self, local_path, remote_path, device_id=None):
        """Push file via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["push", local_path, remote_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True
        except Exception:
            return False

    def adb_pull_file(self, remote_path, local_path, device_id=None):
        """Pull file via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["pull", remote_path, local_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True
        except Exception:
            return False

    # Frida-related methods
    def get_available_frida_versions(self, max_versions=10):
        """Fetch available Frida versions from GitHub releases"""
        try:
            import json
            
            if not requests:
                return None
                
            print("[*] Fetching available Frida versions from GitHub...")
            url = "https://api.github.com/repos/frida/frida/releases"
            
            response = requests.get(url, timeout=10)
            if response.status_code != 200:
                return None
                
            releases = response.json()
            versions = []
            
            for release in releases[:max_versions]:
                if not release.get('prerelease', False):  # Skip pre-releases
                    version = release.get('tag_name', '').strip()
                    if version:
                        versions.append(version)
            
            return versions
            
        except Exception as e:
            print(f"[!] Failed to fetch Frida versions: {e}")
            return None

    def setup_frida_server_interactive(self, frida_server_path=None):
        """Interactive Frida server setup with version selection"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        print("\n" + "="*60)
        print("🔧 FRIDA SERVER SETUP")
        print("="*60)
        
        # Get available versions from GitHub
        available_versions = self.get_available_frida_versions()
        
        if available_versions:
            print("\n📋 Available Frida Versions:")
            print("-" * 40)
            for i, version in enumerate(available_versions, 1):
                print(f"  {i:2d}. {version}")
            
            print(f"  {len(available_versions)+1:2d}. Enter custom version")
            print(f"  {len(available_versions)+2:2d}. Cancel")
            
            while True:
                choice = input(f"\n[?] Select version (1-{len(available_versions)+2}): ").strip()
                
                if not choice:
                    continue
                
                choice_num = int(choice)
                
                if 1 <= choice_num <= len(available_versions):
                    selected_version = available_versions[choice_num - 1]
                    break
    
    def _setup_adb_connection(self):
        """Setup ADB connection and detect device"""
        import shutil
        
        # Find ADB path
        if not self.adb_path:
            self.adb_path = shutil.which("adb")
            if not self.adb_path:
                print("[!] ADB not found in PATH. Please install Android SDK Platform Tools.")
                return False
        
        # Detect device if not specified
        if not self.device_id:
            try:
                result = subprocess.run([self.adb_path, "devices"], capture_output=True, text=True, check=True)
                devices = []
                for line in result.stdout.split('\n')[1:]:
                    if line.strip() and '\tdevice' in line:
                        devices.append(line.split('\t')[0])
                
                if devices:
                    self.device_id = devices[0]
                    print(f"[+] Using device: {self.device_id}")
                else:
                    print("[!] No Android devices connected.")
                    return False
            except Exception as e:
                print(f"[!] Failed to detect devices: {e}")
                return False
        
        return True
    
    def check_emulator_root_status(self):
        """Check if connected device is emulator with root access"""
        if not self.adb_path or not self.device_id:
            return False, False, False, "[!] ADB not available or no device connected"
        
        try:
            # Check if it's an emulator
            model_result = subprocess.run([self.adb_path, "-s", self.device_id, "shell", "getprop", "ro.product.model"], 
                                        capture_output=True, text=True, check=True)
            is_emulator = "sdk" in model_result.stdout.lower() or "emulator" in model_result.stdout.lower()
            
            # Check root access
            root_result = subprocess.run([self.adb_path, "-s", self.device_id, "shell", "su", "-c", "id"], 
                                       capture_output=True, text=True, timeout=5)
            has_root = root_result.returncode == 0 and "uid=0" in root_result.stdout
            
            # Check writable system
            remount_result = subprocess.run([self.adb_path, "-s", self.device_id, "shell", "mount | grep system"], 
                                          capture_output=True, text=True, check=True)
            is_writable = "rw" in remount_result.stdout
            
            message = f"Device: {'Emulator' if is_emulator else 'Physical'}, Root: {'Yes' if has_root else 'No'}, Writable: {'Yes' if is_writable else 'No'}"
            return is_emulator, has_root, is_writable, message
            
        except Exception as e:
            return False, False, False, f"[!] Error checking status: {e}"
    
    def setup_emulator_with_playstore_and_root(self):
        """Guide for setting up emulator with Play Store and root"""
        print("\n" + "="*60)
        print("📱 ANDROID EMULATOR SETUP GUIDE")
        print("="*60)
        print("\n1. Install Android Studio and create AVD")
        print("2. Use Google APIs (not Google Play) for root access")
        print("3. Start with: emulator -avd YourAVD -writable-system")
        print("4. Run: adb root && adb remount")
        print("5. Install Magisk for root management")
        print("\nFor detailed steps, see the documentation.")
    
    def _collect_device_info(self):
        """Collect device information"""
        if not self.adb_path or not self.device_id:
            return {}
        
        info = {}
        try:
            # Get device properties
            props = ["ro.product.model", "ro.build.version.release", "ro.product.manufacturer"]
            for prop in props:
                result = subprocess.run([self.adb_path, "-s", self.device_id, "shell", "getprop", prop], 
                                      capture_output=True, text=True, check=True)
                info[prop] = result.stdout.strip()
            
            print(f"\n[+] Device Info:")
            print(f"    Model: {info.get('ro.product.model', 'Unknown')}")
            print(f"    Android: {info.get('ro.build.version.release', 'Unknown')}")
            print(f"    Manufacturer: {info.get('ro.product.manufacturer', 'Unknown')}")
            
        except Exception as e:
            print(f"[!] Failed to collect device info: {e}")
        
        return info
    
    def menu_stop_frida_server(self):
        """Stop Frida server on device"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        try:
            # Kill frida-server process
            result = subprocess.run([self.adb_path, "-s", self.device_id, "shell", "pkill", "frida-server"], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                print("[+] Frida server stopped")
                return True
            else:
                print("[!] Failed to stop Frida server or it wasn't running")
                return False
        except Exception as e:
            print(f"[!] Error stopping Frida server: {e}")
            return False
    
    def _setup_frida_server_optional(self):
        """Optional Frida server setup check"""
        print("[*] Checking Frida server status...")
        # This is a simplified check - could be expanded
        return True
    
    def run_fridump(self, output_dir="./output/fridump"):
        """Run fridump to dump memory"""
        print(f"[*] Running fridump with output directory: {output_dir}")
        # Implementation would go here
        print("[!] fridump functionality not fully implemented")
        return False
    
    def run_jadx_decompile(self, apk_path, output_dir=None):
        """Run JADX to decompile APK"""
        jadx_path = "./tools/jadx-1.5.2/bin/jadx.bat" if platform.system() == "Windows" else "./tools/jadx-1.5.2/bin/jadx"
        
        if not os.path.exists(jadx_path):
            return False, "", "", "[!] JADX not found. Please install it in tools directory."
        
        output_dir = output_dir or os.path.splitext(apk_path)[0] + "_jadx_out"
        cmd = [jadx_path, "-d", output_dir, apk_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] APK decompiled with JADX to: {output_dir}"
        except Exception as e:
            return False, "", str(e), f"[!] JADX failed: {e}"
    
    def run_apk_components_inspector(self, apk_path):
        """Run APK components inspector"""
        inspector_path = "./tools/apk-components-inspector/apk-components-inspector.py"
        
        if not os.path.exists(inspector_path):
            return False, "", "", "[!] APK Components Inspector not found"
        
        try:
            cmd = [sys.executable, inspector_path, apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, "[+] APK Components Inspector completed"
        except Exception as e:
            return False, "", str(e), f"[!] APK Components Inspector failed: {e}"
    
    def run_frida_script_gen(self, apk_path, output_file=None, extra_args=None):
        """Run Frida script generator"""
        script_gen_path = "./tools/frida-script-gen/frida-script-gen.py"
        
        if not os.path.exists(script_gen_path):
            return False, "", "", "[!] Frida Script Generator not found"
        
        try:
            cmd = [sys.executable, script_gen_path, apk_path]
            if output_file:
                cmd.extend(["-o", output_file])
            if extra_args:
                cmd.extend(extra_args)
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, "[+] Frida Script Generator completed"
        except Exception as e:
            return False, "", str(e), f"[!] Frida Script Generator failed: {e}"
    
    def run_mobapp_storage_inspector(self, apk_path=None):
        """Run MobApp Storage Inspector"""
        jar_path = "./tools/MobApp-Storage-Inspector.jar"
        apk_path = apk_path or self.apk_path
        
        if not os.path.exists(jar_path):
            return False, "", "", "[!] MobApp-Storage-Inspector.jar not found"
        
        if not apk_path:
            return False, "", "", "[!] No APK path provided"
        
        try:
            cmd = ["java", "-jar", jar_path, apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, "[+] MobApp Storage Inspector completed"
        except Exception as e:
            return False, "", str(e), f"[!] MobApp Storage Inspector failed: {e}"
    
    def setup_burp_certificate(self, burp_cert_path=None, device_id=None):
        """Setup Burp Suite certificate on device"""
        cert_path = burp_cert_path or "./tools/9a5ba575.0"
        device_id = device_id or self.device_id
        
        if not os.path.exists(cert_path):
            print(f"[!] Certificate not found at: {cert_path}")
            return False
        
        try:
            # Push certificate to device
            push_result = self.adb_push_file(cert_path, "/system/etc/security/cacerts/", device_id=device_id)
            if push_result:
                print("[+] Burp certificate installed successfully")
                return True
            else:
                print("[!] Failed to install Burp certificate")
                return False
        except Exception as e:
            print(f"[!] Error installing certificate: {e}")
            return False
    
    def _run_with_extended_timeout(self, cmd, operation_name, timeout_seconds):
        """Run command with extended timeout"""
        try:
            print(f"[*] Running {operation_name} (timeout: {timeout_seconds}s)...")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout_seconds)
            return result
        except subprocess.TimeoutExpired:
            print(f"[!] {operation_name} timed out after {timeout_seconds} seconds")
            raise
        except Exception as e:
            print(f"[!] Error during {operation_name}: {e}")
            raise
    
    def find_sensitive_strings(self):
        """Scan APK or decompiled code for secrets using truffleHog."""
        if not self.apk_path:
            print("[!] No APK path specified")
            return []
        if not os.path.exists(self.apk_path):
            print(f"[!] APK file not found: {self.apk_path}")
            return []
        print(f"[*] Scanning {self.apk_path} for secrets using truffleHog...")
        # Try to use APKTool to decompile first
        temp_dir = os.path.splitext(self.apk_path)[0] + "_trufflehog_scan"
        success, stdout, stderr, message = self.run_apktool(self.apk_path, temp_dir)
        scan_path = temp_dir if success and os.path.exists(temp_dir) else self.apk_path
        try:
            import subprocess
            cmd = ["trufflehog", "filesystem", scan_path, "--json"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            findings = []
            if result.stdout:
                import json
                for line in result.stdout.splitlines():
                    try:
                        data = json.loads(line)
                        if 'reason' in data and 'path' in data:
                            findings.append(f"{data['path']}: {data['reason']}")
                    except Exception:
                        continue
            if not findings:
                print("[*] No secrets found by truffleHog.")
            else:
                print(f"[+] Found {len(findings)} potential secrets with truffleHog.")
            # Clean up temp dir
            if scan_path == temp_dir and os.path.exists(temp_dir):
                try:
                    shutil.rmtree(temp_dir)
                except Exception:
                    pass
            return findings
        except Exception as e:
            print(f"[!] Error running truffleHog: {e}")
            return []
    
    def adb_backup_app(self, package, backup_path):
        """Backup app data using ADB backup"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        if not package:
            print("[!] Package name required")
            return False
        
        # Ensure output directory exists
        os.makedirs(os.path.dirname(backup_path), exist_ok=True)
        
        print(f"[*] Creating backup of {package}...")
        print(f"[*] Backup will be saved to: {backup_path}")
        print("[*] You may need to confirm backup on the device...")
        
        try:
            cmd = [self.adb_path]
            if self.device_id:
                cmd += ["-s", self.device_id]
            cmd += ["backup", "-f", backup_path, "-apk", "-shared", "-nosystem", package]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)  # 5 minute timeout
            
            if result.returncode == 0 and os.path.exists(backup_path):
                file_size = os.path.getsize(backup_path)
                print(f"[+] Backup completed successfully!")
                print(f"[+] Backup file size: {file_size / (1024*1024):.2f} MB")
                return True
            else:
                print(f"[!] Backup failed. Return code: {result.returncode}")
                if result.stderr:
                    print(f"[!] Error: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print("[!] Backup timed out. This may indicate the backup was cancelled on device.")
            return False
        except Exception as e:
            print(f"[!] Error during backup: {e}")
            return False
    
    def adb_restore_app(self, package, backup_path):
        """Restore app data using ADB restore"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        if not backup_path or not os.path.exists(backup_path):
            print(f"[!] Backup file not found: {backup_path}")
            return False
        
        print(f"[*] Restoring backup from: {backup_path}")
        print("[*] You may need to confirm restore on the device...")
        
        try:
            cmd = [self.adb_path]
            if self.device_id:
                cmd += ["-s", self.device_id]
            cmd += ["restore", backup_path]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)  # 5 minute timeout
            
            if result.returncode == 0:
                print(f"[+] Restore completed successfully!")
                return True
            else:
                print(f"[!] Restore failed. Return code: {result.returncode}")
                if result.stderr:
                    print(f"[!] Error: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print("[!] Restore timed out. This may indicate the restore was cancelled on device.")
            return False
        except Exception as e:
            print(f"[!] Error during restore: {e}")
            return False
    
    def repackage_apk(self, output_path):
        """Repackage APK after modification"""
        if not self.apk_path:
            print("[!] No APK path specified")
            return False
        
        if not os.path.exists(self.apk_path):
            print(f"[!] APK file not found: {self.apk_path}")
            return False
        
        print(f"[*] Repackaging APK: {self.apk_path}")
        
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        try:
            # Step 1: Decompile the APK
            temp_dir = os.path.splitext(self.apk_path)[0] + "_repackage_temp"
            print("[*] Step 1: Decompiling APK...")
            success, stdout, stderr, message = self.run_apktool(self.apk_path, temp_dir)
            
            if not success:
                print(f"[!] Failed to decompile APK: {message}")
                return False
            
            print("[*] Step 2: APK decompiled successfully")
            print("[*] You can now modify files in the decompiled directory if needed")
            print(f"[*] Decompiled location: {temp_dir}")
            
            # Step 3: Recompile the APK
            print("[*] Step 3: Recompiling APK...")
            apktool_cmd = "apktool.bat" if platform.system() == "Windows" else "apktool"
            apktool_path = shutil.which(apktool_cmd)
            
            if not apktool_path:
                print("[!] apktool not found in PATH")
                return False
            
            # Build the APK
            cmd = [apktool_path, "b", temp_dir, "-o", output_path]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            if os.path.exists(output_path):
                print(f"[+] APK repackaged successfully!")
                print(f"[+] Output: {output_path}")
                print("[!] Note: The repackaged APK will need to be signed before installation")
                print("[!] Use: jarsigner or apksigner to sign the APK")
                
                # Clean up temporary directory
                try:
                    shutil.rmtree(temp_dir)
                except Exception:
                    pass
                
                return True
            else:
                print("[!] Repackaging failed - output file not created")
                return False
                
        except subprocess.CalledProcessError as e:
            print(f"[!] APK repackaging failed: {e}")
            if e.stderr:
                print(f"[!] Error details: {e.stderr}")
            return False
        except Exception as e:
            print(f"[!] Unexpected error during repackaging: {e}")
            return False
    
    def uninstall_app_and_clean(self, package):
        """Uninstall app and clean related data"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        if not package:
            print("[!] Package name required")
            return False
        
        print(f"[*] Uninstalling and cleaning: {package}")
        
        try:
            # Step 1: Uninstall the app
            print("[*] Step 1: Uninstalling app...")
            uninstall_success = self.adb_uninstall_apk(package, device_id=self.device_id)
            
            if uninstall_success:
                print("[+] App uninstalled successfully")
            else:
                print("[!] App uninstall failed or app was not installed")
                # Continue with cleanup anyway
            
            # Step 2: Clear app data directories (requires root)
            print("[*] Step 2: Cleaning app data directories...")
            
            # Try to clean common app data locations
            data_paths = [
                f"/data/data/{package}",
                f"/sdcard/Android/data/{package}",
                f"/storage/emulated/0/Android/data/{package}",
                f"/data/app/{package}*",
                f"/data/user/0/{package}"
            ]
            
            cleaned_paths = []
            
            for path in data_paths:
                try:
                    # Try with root access first
                    cmd = [self.adb_path]
                    if self.device_id:
                        cmd += ["-s", self.device_id]
                    cmd += ["shell", "su", "-c", f"rm -rf {path}"]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        cleaned_paths.append(path)
                        print(f"[+] Cleaned: {path}")
                    else:
                        # Try without root
                        cmd = [self.adb_path]
                        if self.device_id:
                            cmd += ["-s", self.device_id]
                        cmd += ["shell", "rm", "-rf", path]
                        
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            cleaned_paths.append(path)
                            print(f"[+] Cleaned: {path}")
                        else:
                            print(f"[*] Could not clean: {path} (may not exist or require root)")
                            
                except Exception:
                    continue
            
            # Step 3: Clear app cache and other locations
            print("[*] Step 3: Clearing additional app data...")
            
            cache_paths = [
                f"/data/dalvik-cache/arm/*{package}*",
                f"/data/dalvik-cache/arm64/*{package}*",
                f"/cache/dalvik-cache/*{package}*"
            ]
            
            for path in cache_paths:
                try:
                    cmd = [self.adb_path]
                    if self.device_id:
                        cmd += ["-s", self.device_id]
                    cmd += ["shell", "su", "-c", f"rm -rf {path}"]
                    
                    subprocess.run(cmd, capture_output=True, text=True, timeout=5)
                except Exception:
                    continue
            
            print(f"[+] Cleanup completed!")
            print(f"[+] Cleaned {len(cleaned_paths)} data directories")
            
            if cleaned_paths:
                print("[+] Cleaned directories:")
                for path in cleaned_paths:
                    print(f"    - {path}")
            
            return True
            
        except Exception as e:
            print(f"[!] Error during uninstall and cleanup: {e}")
            return False
                     
