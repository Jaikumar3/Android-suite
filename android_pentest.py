# --- List Installed Packages ---
def list_installed_packages(device_id=None):
    """
    List all installed package names on the connected Android device.
    Returns a list of package names (strings).
    """
    import shutil
    import subprocess
    adb_path = shutil.which("adb")
    if not adb_path:
        print("[!] adb not found in PATH. Please install platform-tools and add to PATH.")
        return []
    cmd = [adb_path]
    if device_id:
        cmd += ["-s", device_id]
    cmd += ["shell", "pm", "list", "packages"]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        packages = [line.replace("package:", "").strip() for line in result.stdout.splitlines() if line.strip()]
        return packages
    except Exception as e:
        print(f"[!] Error listing packages: {e}")
        return []
# --- Extract App Data Directory ---
def extract_app_data_directory(package, dest_dir, device_id=None):
    """
    Extract the /data/data/<package> directory from the device using adb (root required).
    Returns (success: bool, message: str)
    """
    import shutil
    import subprocess
    import os
    adb_path = shutil.which("adb")
    if not adb_path:
        return False, "[!] adb not found in PATH. Please install platform-tools and add to PATH."
    if not package:
        return False, "[!] No package name provided."
    os.makedirs(dest_dir, exist_ok=True)
    adb_cmd = [adb_path]
    if device_id:
        adb_cmd += ["-s", device_id]
    adb_cmd += ["pull", f"/data/data/{package}", dest_dir]
    try:
        result = subprocess.run(adb_cmd, capture_output=True, text=True)
        if result.returncode == 0:
            return True, f"[+] App data extracted to {dest_dir}"
        else:
            return False, f"[!] Failed to extract app data. Output:\n{result.stderr}"
    except Exception as e:
        return False, f"[!] Error running adb: {e}"
# --- APKTool and APKLeaks Integration ---
import platform

def run_apktool(apk_path, output_dir=None, extra_args=None):
    """Run apktool to decompile APK. Returns True if successful."""
    apktool_cmd = "apktool.bat" if platform.system() == "Windows" else "apktool"
    apktool_path = shutil.which(apktool_cmd)
    if not apktool_path:
        print("[!] apktool not found in PATH. Please install it and ensure it's available.")
        return False
    output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apktool_out"
    cmd = [apktool_path, "d", apk_path, "-o", output_dir, "-f"]
    if extra_args:
        cmd.extend(extra_args)
    print(f"Running: {' '.join(cmd)}")
    try:
        subprocess.run(cmd, check=True)
        print(f"✓ APK decompiled to: {output_dir}")
        return True
    except Exception as e:
        print(f"[!] apktool failed: {e}")
        return False

def run_apkleaks(apk_path, output_dir=None, extra_args=None):
    """Run APKLeaks on the APK. Returns True if successful."""
    apkleaks_path = shutil.which("apkleaks")
    if not apkleaks_path:
        print("[!] apkleaks not found in PATH. Please install it (pip install apkleaks).")
        return False
    output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apkleaks_out"
    os.makedirs(output_dir, exist_ok=True)
    cmd = [apkleaks_path, "-f", apk_path, "-o", output_dir]
    if extra_args:
        cmd.extend(extra_args)
    print(f"Running: {' '.join(cmd)}")
    try:
        subprocess.run(cmd, check=True)
        print(f"✓ APKiLeaks results saved to: {output_dir}")
        return True
    except Exception as e:
        print(f"[!] apkleaks failed: {e}")
        return False
def get_pid_for_package(package_name, device_id=None):
    """Get PID for a running package using adb. Returns list of (pid, process_name) tuples."""
    import shutil
    import subprocess
    adb_path = shutil.which("adb")
    if not adb_path:
        print("ADB not found in PATH. Please install platform-tools and add to PATH.")
        return []
    try:
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["shell", "ps"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        matches = []
        for line in result.stdout.splitlines():
            if package_name in line:
                parts = line.split()
                if len(parts) > 1:
                    pid = parts[1]
                    proc_name = parts[-1]
                    matches.append((pid, proc_name))
        return matches
    except Exception as e:
        print(f"Error running adb: {e}")
        return []

# --- ADB Utility Functions ---
import shutil
import subprocess
import os
import time
from pathlib import Path
import json
import os
import time

def adb_install_apk(apk_path, device_id=None):
    adb_path = shutil.which("adb")
    if not adb_path:
        print("ADB not found in PATH.")
        return False
    cmd = [adb_path]
    if device_id:
        cmd += ["-s", device_id]
    cmd += ["install", "-r", apk_path]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(result.stdout.strip())
        return "Success" in result.stdout
    except Exception as e:
        print(f"Error installing APK: {e}")
        return False

def adb_uninstall_apk(package_name, device_id=None):
    adb_path = shutil.which("adb")
    if not adb_path:
        print("ADB not found in PATH.")
        return False
    cmd = [adb_path]
    if device_id:
        cmd += ["-s", device_id]
    cmd += ["uninstall", package_name]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(result.stdout.strip())
        return "Success" in result.stdout
    except Exception as e:
        print(f"Error uninstalling APK: {e}")
        return False

def adb_push_file(local_path, remote_path, device_id=None):
    adb_path = shutil.which("adb")
    if not adb_path:
        print("ADB not found in PATH.")
        return False
    cmd = [adb_path]
    if device_id:
        cmd += ["-s", device_id]
    cmd += ["push", local_path, remote_path]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(result.stdout.strip())
        return True
    except Exception as e:
        print(f"Error pushing file: {e}")
        return False

def adb_pull_file(remote_path, local_path, device_id=None):
    adb_path = shutil.which("adb")
    if not adb_path:
        print("ADB not found in PATH.")
        return False
    cmd = [adb_path]
    if device_id:
        cmd += ["-s", device_id]
    cmd += ["pull", remote_path, local_path]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(result.stdout.strip())
        return True
    except Exception as e:
        print(f"Error pulling file: {e}")
        return False

# ...rest of the file remains unchanged...

class AndroidPentester:
    def menu_stop_frida_server(self):
        """Menu wrapper to stop Frida server with user feedback."""
        result = self.stop_frida_server()
        if result:
            print("[+] Frida server stopped successfully.")
        else:
            print("[!] Failed to stop Frida server or it was not running.")
    def stop_frida_server(self):
        """Stop/kill the Frida server process on the device."""
        print("\n[FRIDA] Stopping Frida server on device...")
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available for Frida server stop")
            return False
        try:
            # Use pkill if available, otherwise fallback to kill
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "pkill frida-server"
            ], capture_output=True, text=True)
            # Check if process still running
            check = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps | grep frida-server"
            ], capture_output=True, text=True)
            if check.stdout.strip():
                # Try killall as fallback
                subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell", "killall frida-server"
                ], capture_output=True, text=True)
                # Check again
                check2 = subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell", "ps | grep frida-server"
                ], capture_output=True, text=True)
                if check2.stdout.strip():
                    print("✗ Failed to stop Frida server (process still running)")
                    return False
            print("✓ Frida server stopped on device.")
            return True
        except Exception as e:
            print(f"✗ Error stopping Frida server: {e}")
            return False
    def run_fridump(self, output_dir=None, extra_args=None):
        """Run fridump to dump APK memory using Frida. Handles subprocess call internally."""
        import sys
        import subprocess
        if not self.app_name:
            print("[!] Package name is required to run fridump.")
            return False
        script_path = os.path.join("tools", "fridump", "fridump.py")
        if not os.path.exists(script_path):
            print(f"[!] fridump.py not found at {script_path}")
            return False
        output_dir = output_dir or os.path.join(str(self.output_dir), "fridump")
        os.makedirs(output_dir, exist_ok=True)
        cmd = [sys.executable, script_path, "-U", "-n", self.app_name, "-o", output_dir]
        if extra_args:
            cmd.extend(extra_args)
        print(f"Running: {' '.join(cmd)}")
        try:
            subprocess.run(cmd, check=True)
            print(f"✓ fridump completed. Dumped files are in: {output_dir}")
            return True
        except Exception as e:
            print(f"[!] fridump failed: {e}")
            return False
    def get_logcat(self, filter_tag=None, save_to_file=None, lines=200):
        """Fetch logcat output from the device. Optionally filter by tag and save to file."""
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available")
            return None
        cmd = [self.adb_path, "-s", self.device_id, "logcat", f"-d", f"-t", str(lines)]
        if filter_tag:
            cmd += [f"*:{filter_tag}"]
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            log_output = result.stdout
            if save_to_file:
                with open(save_to_file, "w", encoding="utf-8") as f:
                    f.write(log_output)
                print(f"✓ Logcat output saved to: {save_to_file}")
            else:
                print(log_output)
            return log_output
        except Exception as e:
            print(f"Error fetching logcat: {e}")
            return None
    def _download_and_push_frida_server(self, host_version, frida_server_path):
        """Download the correct frida-server for the device arch and push to device"""
        import requests, zipfile, io, shutil
        # 1. Get device architecture
        print("Detecting device architecture...")
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "getprop", "ro.product.cpu.abi"
            ], capture_output=True, text=True, check=True)
            arch = result.stdout.strip()
            print(f"Device architecture: {arch}")
        except Exception as e:
            print(f"Could not detect device architecture: {e}")
            return False
        # 2. Map arch to frida-server asset name
        arch_map = {
            "arm64-v8a": "android-arm64",
            "armeabi-v7a": "android-arm",
            "x86_64": "android-x86_64",
            "x86": "android-x86"
        }
        asset_arch = arch_map.get(arch)
        if not asset_arch:
            print(f"Unsupported device architecture: {arch}")
            return False
        # 3. Download frida-server from GitHub
        github_url = f"https://github.com/frida/frida/releases/download/{host_version}/frida-server-{host_version}-{asset_arch}.xz"
        print(f"Downloading frida-server from: {github_url}")
        try:
            r = requests.get(github_url, stream=True)
            if r.status_code != 200:
                print(f"Failed to download frida-server: HTTP {r.status_code}")
                return False
            # Save to temp file
            temp_xz = Path("./frida-server.xz")
            with open(temp_xz, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
            # Extract xz (no zip, it's xz compressed)
            import lzma
            temp_bin = Path("./frida-server")
            with lzma.open(temp_xz, "rb") as f_in, open(temp_bin, "wb") as f_out:
                shutil.copyfileobj(f_in, f_out)
            temp_xz.unlink()
            # 4. Push to device
            print(f"Pushing frida-server to device: {frida_server_path}")
            subprocess.run([
                self.adb_path, "-s", self.device_id, "push", str(temp_bin), frida_server_path
            ], check=True)
            subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "chmod", "755", frida_server_path
            ], check=True)
            temp_bin.unlink()
            print("✓ frida-server pushed and permissions set.")
            return True
        except Exception as e:
            print(f"Failed to download or push frida-server: {e}")
            return False
    """Main class for Android penetration testing automation"""
    
    def __init__(self, apk_path, app_name=None, process_id=None, device_id=None, output_dir="./output"):
        """
        Initialize the Android Pentester
        
        Args:
            apk_path (str): Path to the APK file
            app_name (str): Application package name or name
            process_id (int): Process ID of running application
            device_id (str): Specific Android device ID
            output_dir (str): Directory for output files
        """
        self.apk_path = apk_path
        self.app_name = app_name
        self.process_id = process_id
        self.device_id = device_id
        self.output_dir = Path(output_dir)
        
        # Create output directory
        self.output_dir.mkdir(exist_ok=True)
        
        # Tool paths (will be set during dependency check)
        self.adb_path = None
        self.aapt_path = None
        self.jadx_path = None
        
    def install_dependencies(self):
        """Install and setup required dependencies for Android pentesting"""
        print("For installation, please use the separate installer script:")
        print("  python installer.py --standard    # Standard installation")
        print("  python installer.py --full        # Full installation with all tools")
        print("  python installer.py --minimal     # Minimal installation")
        print("  python installer.py --frida-only  # Frida tools only")
        print("  python installer.py --verify-only # Verify existing installation")
        print("")
        print("Checking existing tools...")
        
        # Check for Android SDK tools
        self._check_android_tools()
        
    def _check_android_tools(self):
        """Check for required Android tools and provide installation guidance"""
        print("\nChecking Android SDK tools...")
        
        # Check for ADB
        self.adb_path = shutil.which("adb")
        if self.adb_path:
            print(f"✓ ADB found at: {self.adb_path}")
        else:
            print("✗ ADB not found. Please install Android SDK Platform Tools")
            print("  Download from: https://developer.android.com/studio/releases/platform-tools")
        
        # Check for AAPT
        self.aapt_path = shutil.which("aapt")
        if self.aapt_path:
            print(f"✓ AAPT found at: {self.aapt_path}")
        else:
            print("✗ AAPT not found. Please install Android SDK Build Tools")
        
        # Check for JADX (optional)
        self.jadx_path = shutil.which("jadx")
        if self.jadx_path:
            print(f"✓ JADX found at: {self.jadx_path}")
        else:
            print("! JADX not found (optional). Download from: https://github.com/skylot/jadx")
    
    def run_automation(self):
        """Run the complete Android pentesting automation workflow"""
        print(f"\n{'='*60}")
        print("ANDROID PENTESTING AUTOMATION STARTING")
        print(f"{'='*60}")
        
        # Step 1: Validate APK
        self._validate_apk()
        
        # Step 2: Extract APK information
        apk_info = self._extract_apk_info()
        
        # Step 3: Setup ADB connection
        self._setup_adb_connection()
        
        # Step 4: Install APK (if not installed)
        self._install_apk()
        
        # Step 5: Collect device information
        device_info = self._collect_device_info()
        
        # Step 6: Application analysis
        if self.app_name:
            self._analyze_application()
        
        # Step 7: Process monitoring (if PID provided)
        if self.process_id:
            self._monitor_process()
        
        # Step 8: Setup Frida server (optional)
        self._setup_frida_server_optional()
        
        # Step 9: Get process list
        self._get_process_list()
        
        # Step 10: Security checks
        self._run_security_checks()
        
        # Step 11: Generate report
        self._generate_report(apk_info, device_info)
        
        print(f"\n{'='*60}")
        print("AUTOMATION COMPLETED")
        print(f"Results saved in: {self.output_dir}")
        print(f"{'='*60}")
    
    def _validate_apk(self):
        """Validate the provided APK file"""
        print(f"\n[1] Validating APK file: {self.apk_path}")
        
        if not os.path.exists(self.apk_path):
            raise FileNotFoundError(f"APK file not found: {self.apk_path}")
        
        # Check file extension
        if not self.apk_path.lower().endswith('.apk'):
            print("Warning: File doesn't have .apk extension")
        
        # Check file size
        file_size = os.path.getsize(self.apk_path)
        print(f"APK file size: {file_size / (1024*1024):.2f} MB")
        
        print("✓ APK validation completed")
    
    def _extract_apk_info(self):
        """Extract information from APK using AAPT"""
        print("\n[2] Extracting APK information...")
        
        apk_info = {}
        
        if self.aapt_path:
            try:
                # Get package info
                result = subprocess.run([
                    self.aapt_path, "dump", "badging", self.apk_path
                ], capture_output=True, text=True, check=True)
                
                # Parse AAPT output
                for line in result.stdout.split('\n'):
                    if line.startswith('package:'):
                        # Extract package name
                        if "name='" in line:
                            start = line.find("name='") + 6
                            end = line.find("'", start)
                            apk_info['package_name'] = line[start:end]
                        
                        # Extract version
                        if "versionName='" in line:
                            start = line.find("versionName='") + 13
                            end = line.find("'", start)
                            apk_info['version'] = line[start:end]
                    
                    elif line.startswith('application-label:'):
                        start = line.find("'") + 1
                        end = line.rfind("'")
                        apk_info['app_label'] = line[start:end]
                
                # Set app_name if not provided
                if not self.app_name and 'package_name' in apk_info:
                    self.app_name = apk_info['package_name']
                
                print(f"✓ Package: {apk_info.get('package_name', 'Unknown')}")
                print(f"✓ Version: {apk_info.get('version', 'Unknown')}")
                print(f"✓ Label: {apk_info.get('app_label', 'Unknown')}")
                
            except subprocess.CalledProcessError as e:
                print(f"✗ Failed to extract APK info: {e}")
                apk_info = {'package_name': self.app_name or 'Unknown'}
        else:
            print("! AAPT not available, skipping APK analysis")
            apk_info = {'package_name': self.app_name or 'Unknown'}
        
        return apk_info
    
    def _setup_adb_connection(self):
        """Setup ADB connection to Android device"""
        print("\n[3] Setting up ADB connection...")
        
        if not self.adb_path:
            print("✗ ADB not available, skipping device operations")
            return
        
        try:
            # Start ADB server
            subprocess.run([self.adb_path, "start-server"], check=True, capture_output=True)
            
            # List connected devices
            result = subprocess.run([
                self.adb_path, "devices"
            ], capture_output=True, text=True, check=True)
            
            devices = []
            for line in result.stdout.split('\n')[1:]:
                if line.strip() and '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
            
            if not devices:
                print("✗ No Android devices connected")
                print("  Please connect an Android device with USB debugging enabled")
                return
            
            if self.device_id and self.device_id not in devices:
                print(f"✗ Specified device {self.device_id} not found")
                return
            
            if not self.device_id:
                self.device_id = devices[0]
            
            print(f"✓ Connected to device: {self.device_id}")
            
        except subprocess.CalledProcessError as e:
            print(f"✗ ADB connection failed: {e}")
    
    def _install_apk(self):
        """Install the APK on the connected device"""
        print("\n[4] Installing APK...")
        
        if not self.adb_path or not self.device_id:
            print("! Skipping APK installation (ADB not available)")
            return
        
        try:
            cmd = [self.adb_path, "-s", self.device_id, "install", "-r", self.apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            if "Success" in result.stdout:
                print("✓ APK installed successfully")
            else:
                print(f"! APK installation result: {result.stdout.strip()}")
                
        except subprocess.CalledProcessError as e:
            print(f"✗ APK installation failed: {e}")
    
    def _collect_device_info(self):
        """Collect device information"""
        print("\n[5] Collecting device information...")
        
        device_info = {}
        
        if not self.adb_path or not self.device_id:
            print("! Skipping device info collection (ADB not available)")
            return device_info
        
        info_commands = {
            "android_version": ["getprop", "ro.build.version.release"],
            "sdk_version": ["getprop", "ro.build.version.sdk"],
            "device_model": ["getprop", "ro.product.model"],
            "device_brand": ["getprop", "ro.product.brand"],
            "architecture": ["getprop", "ro.product.cpu.abi"]
        }
        
        for key, cmd in info_commands.items():
            try:
                result = subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell"
                ] + cmd, capture_output=True, text=True, check=True)
                
                device_info[key] = result.stdout.strip()
                print(f"✓ {key.replace('_', ' ').title()}: {device_info[key]}")
                
            except subprocess.CalledProcessError:
                device_info[key] = "Unknown"
        
        return device_info
    
    def _analyze_application(self):
        """Analyze the installed application"""
        print(f"\n[6] Analyzing application: {self.app_name}")
        
        if not self.adb_path or not self.device_id:
            print("! Skipping application analysis (ADB not available)")
            return
        
        try:
            # Check if app is running
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps | grep", self.app_name
            ], capture_output=True, text=True)
            
            if result.stdout.strip():
                print("✓ Application is currently running")
                # Extract PID if not provided
                if not self.process_id:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if self.app_name in line:
                            parts = line.split()
                            if len(parts) >= 2:
                                try:
                                    self.process_id = int(parts[1])
                                    print(f"✓ Found PID: {self.process_id}")
                                    break
                                except ValueError:
                                    continue
            else:
                print("! Application is not currently running")
            
            # Get application info
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "dumpsys", "package", self.app_name
            ], capture_output=True, text=True)
            
            if result.stdout:
                # Save dumpsys output
                dumpsys_file = self.output_dir / f"{self.app_name}_dumpsys.txt"
                with open(dumpsys_file, 'w') as f:
                    f.write(result.stdout)
                print(f"✓ Package info saved to: {dumpsys_file}")
            
        except subprocess.CalledProcessError as e:
            print(f"✗ Application analysis failed: {e}")
    
    def _monitor_process(self):
        """Monitor the specified process"""
        print(f"\n[7] Monitoring process: {self.process_id}")
        
        if not self.adb_path or not self.device_id:
            print("! Skipping process monitoring (ADB not available)")
            return
        
        try:
            # Get process information
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps", "-p", str(self.process_id)
            ], capture_output=True, text=True)
            
            if result.stdout.strip():
                print("✓ Process is running")
                
                # Get memory usage
                mem_result = subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell", "dumpsys", "meminfo", str(self.process_id)
                ], capture_output=True, text=True)
                
                if mem_result.stdout:
                    # Save memory info
                    meminfo_file = self.output_dir / f"pid_{self.process_id}_meminfo.txt"
                    with open(meminfo_file, 'w') as f:
                        f.write(mem_result.stdout)
                    print(f"✓ Memory info saved to: {meminfo_file}")
            else:
                print(f"✗ Process {self.process_id} not found")
                
        except subprocess.CalledProcessError as e:
            print(f"✗ Process monitoring failed: {e}")
    
    def _run_security_checks(self):
        """Run basic security checks"""
        print("\n[8] Running security checks...")
        
        security_results = []
        
        # Check 1: APK permissions
        if self.aapt_path:
            try:
                result = subprocess.run([
                    self.aapt_path, "dump", "permissions", self.apk_path
                ], capture_output=True, text=True, check=True)
                
                permissions = result.stdout.strip().split('\n')
                dangerous_permissions = [
                    'android.permission.READ_SMS',
                    'android.permission.SEND_SMS',
                    'android.permission.READ_CONTACTS',
                    'android.permission.ACCESS_FINE_LOCATION',
                    'android.permission.CAMERA',
                    'android.permission.RECORD_AUDIO',
                    'android.permission.READ_EXTERNAL_STORAGE',
                    'android.permission.WRITE_EXTERNAL_STORAGE'
                ]
                
                found_dangerous = []
                for perm in permissions:
                    perm = perm.strip().replace('uses-permission: name=\'', '').replace('\'', '')
                    if perm in dangerous_permissions:
                        found_dangerous.append(perm)
                
                if found_dangerous:
                    security_results.append(f"Dangerous permissions found: {', '.join(found_dangerous)}")
                    print(f"⚠ Found {len(found_dangerous)} dangerous permissions")
                else:
                    security_results.append("No dangerous permissions found")
                    print("✓ No dangerous permissions detected")
                
                # Save all permissions
                perms_file = self.output_dir / f"{self.app_name}_permissions.txt"
                with open(perms_file, 'w') as f:
                    f.write('\n'.join(permissions))
                print(f"✓ Permissions saved to: {perms_file}")
                
            except subprocess.CalledProcessError as e:
                security_results.append(f"Permission check failed: {e}")
        
        # Check 2: Debuggable flag
        if self.aapt_path:
            try:
                result = subprocess.run([
                    self.aapt_path, "dump", "xmltree", self.apk_path, "AndroidManifest.xml"
                ], capture_output=True, text=True, check=True)
                
                if "android:debuggable=true" in result.stdout:
                    security_results.append("⚠ Application is debuggable")
                    print("⚠ Application has debuggable flag enabled")
                else:
                    security_results.append("✓ Application is not debuggable")
                    print("✓ Application is not debuggable")
                    
            except subprocess.CalledProcessError:
                security_results.append("Could not check debuggable flag")
        
        # Save security results
        security_file = self.output_dir / "security_checks.txt"
        with open(security_file, 'w') as f:
            f.write('\n'.join(security_results))
        print(f"✓ Security results saved to: {security_file}")
    
    def _generate_report(self, apk_info, device_info):
        """Generate a comprehensive report"""
        print("\n[9] Generating report...")
        
        report = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "apk_path": self.apk_path,
            "apk_info": apk_info,
            "device_info": device_info,
            "app_name": self.app_name,
            "process_id": self.process_id,
            "device_id": self.device_id,
            "output_directory": str(self.output_dir)
        }
        
        # Save JSON report
        report_file = self.output_dir / "pentesting_report.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Generate HTML report
        html_report = self._generate_html_report(report)
        html_file = self.output_dir / "pentesting_report.html"
        with open(html_file, 'w') as f:
            f.write(html_report)
        
        print(f"✓ JSON report saved to: {report_file}")
        print(f"✓ HTML report saved to: {html_file}")
    
    def _generate_html_report(self, report):
        """Generate HTML report"""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Android Pentesting Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}
        .info {{ background-color: #f8f9fa; }}
        .warning {{ background-color: #fff3cd; }}
        .success {{ background-color: #d4edda; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Android Pentesting Automation Report</h1>
        <p>Generated on: {report['timestamp']}</p>
    </div>
    
    <div class="section info">
        <h2>APK Information</h2>
        <table>
            <tr><th>Property</th><th>Value</th></tr>
            <tr><td>APK Path</td><td>{report['apk_path']}</td></tr>
            <tr><td>Package Name</td><td>{report['apk_info'].get('package_name', 'Unknown')}</td></tr>
            <tr><td>Version</td><td>{report['apk_info'].get('version', 'Unknown')}</td></tr>
            <tr><td>App Label</td><td>{report['apk_info'].get('app_label', 'Unknown')}</td></tr>
        </table>
    </div>
    
    <div class="section info">
        <h2>Device Information</h2>
        <table>
            <tr><th>Property</th><th>Value</th></tr>
            <tr><td>Device ID</td><td>{report.get('device_id', 'Unknown')}</td></tr>
            <tr><td>Android Version</td><td>{report['device_info'].get('android_version', 'Unknown')}</td></tr>
            <tr><td>SDK Version</td><td>{report['device_info'].get('sdk_version', 'Unknown')}</td></tr>
            <tr><td>Device Model</td><td>{report['device_info'].get('device_model', 'Unknown')}</td></tr>
            <tr><td>Brand</td><td>{report['device_info'].get('device_brand', 'Unknown')}</td></tr>
            <tr><td>Architecture</td><td>{report['device_info'].get('architecture', 'Unknown')}</td></tr>
        </table>
    </div>
    
    <div class="section info">
        <h2>Analysis Details</h2>
        <table>
            <tr><th>Property</th><th>Value</th></tr>
            <tr><td>Application Name</td><td>{report.get('app_name', 'N/A')}</td></tr>
            <tr><td>Process ID</td><td>{report.get('process_id', 'N/A')}</td></tr>
            <tr><td>Output Directory</td><td>{report['output_directory']}</td></tr>
        </table>
    </div>
    
    <div class="section success">
        <h2>Output Files</h2>
        <p>The following files have been generated in the output directory:</p>
        <ul>
            <li>pentesting_report.json - Machine-readable report</li>
            <li>pentesting_report.html - This HTML report</li>
            <li>*_permissions.txt - Application permissions</li>
            <li>*_dumpsys.txt - Package information dump</li>
            <li>security_checks.txt - Security analysis results</li>
            <li>pid_*_meminfo.txt - Process memory information (if applicable)</li>
        </ul>
    </div>
</body>
</html>
        """
        return html
    
    def _install_additional_tools(self):
        """Install additional pentesting tools like fridump"""
        print("\nInstalling additional pentesting tools...")
        
        # Install fridump via git
        try:
            fridump_dir = Path("./tools/fridump")
            if not fridump_dir.exists():
                print("Installing fridump...")
                subprocess.run([
                    "git", "clone", "https://github.com/Nightbringer21/fridump", str(fridump_dir)
                ], check=True, capture_output=True)
                print("✓ fridump installed successfully")
            else:
                print("✓ fridump already installed")
        except subprocess.CalledProcessError as e:
            print(f"✗ Failed to install fridump: {e}")
        except FileNotFoundError:
            print("! Git not found. Please install Git to download fridump")
    
    def setup_frida_server(self, frida_server_path=None):
        """Setup Frida server on Android device and check version compatibility with host frida-tools. Enforces exact version match."""
        print("\n[FRIDA] Setting up Frida server...")
        import re
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available for Frida setup")
            return False
        try:
            # Get host frida-tools version
            host_version = None
            try:
                result = subprocess.run(["frida", "--version"], capture_output=True, text=True, check=True)
                host_version = result.stdout.strip()
                print(f"Host frida-tools version: {host_version}")
            except Exception:
                print("! Could not determine host frida-tools version")
            if not host_version:
                print("! Cannot continue without host frida-tools version.")
                return False
            # Default Frida server location
            if not frida_server_path:
                frida_server_path = "/data/local/tmp/frida-server"
            # Check if Frida server is already running
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps | grep frida-server"
            ], capture_output=True, text=True)
            if result.stdout.strip():
                print("✓ Frida server is already running")
                # Try to get server version
                server_version = self._get_frida_server_version(frida_server_path)
                if server_version:
                    print(f"Frida server version: {server_version}")
                    if host_version != server_version:
                        print(f"✗ Version mismatch: Host frida-tools is {host_version}, server is {server_version}")
                        print("  Both versions must match exactly. Aborting setup.")
                        return False
                else:
                    print("! Could not determine frida-server version. Aborting setup.")
                    return False
                return True
            # Check if Frida server binary exists on device
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ls", frida_server_path
            ], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"✗ Frida server not found at {frida_server_path}")
                if host_version:
                    print("Attempting to download and push correct frida-server for your device...")
                    if self._download_and_push_frida_server(host_version, frida_server_path):
                        print("✓ frida-server downloaded and pushed.")
                        # Try again to start
                        return self.setup_frida_server(frida_server_path)
                    else:
                        print("! Could not automatically fetch and push frida-server. Please do it manually.")
                else:
                    print("  Please push frida-server binary to device first:")
                    print(f"  adb push frida-server {frida_server_path}")
                    print(f"  adb shell chmod 755 {frida_server_path}")
                return False
            # Try to get server version before starting
            server_version = self._get_frida_server_version(frida_server_path)
            if server_version:
                print(f"Frida server version: {server_version}")
                if host_version != server_version:
                    print(f"✗ Version mismatch: Host frida-tools is {host_version}, server is {server_version}")
                    print("  Both versions must match exactly. Aborting setup.")
                    return False
            else:
                print("! Could not determine frida-server version. Aborting setup.")
                return False
            # Start Frida server
            print("Starting Frida server...")
            subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", f"{frida_server_path} &"
            ], check=True, capture_output=True)
            # Verify Frida server is running
            time.sleep(2)
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps | grep frida-server"
            ], capture_output=True, text=True)
            if result.stdout.strip():
                print("✓ Frida server started successfully")
                return True
            else:
                print("✗ Failed to start Frida server")
                return False
        except subprocess.CalledProcessError as e:
            print(f"✗ Frida setup failed: {e}")
            return False

    def _get_frida_server_version(self, frida_server_path):
        """Attempt to get the Frida server version from the binary on the device"""
        try:
            # Use 'strings' and 'grep' to extract version from the binary
            # This works for most frida-server binaries
            grep_cmd = f"strings {frida_server_path} | grep 'Frida '"
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", grep_cmd
            ], capture_output=True, text=True)
            # Look for a line like 'Frida 16.0.7' or similar
            for line in result.stdout.splitlines():
                if line.strip().startswith("Frida "):
                    return line.strip().split()[1]
        except Exception:
            pass
        return None
    
    def push_file_to_device(self, local_path, remote_path):
        """Push file to Android device"""
        print(f"\n[ADB] Pushing file: {local_path} -> {remote_path}")
        
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available")
            return False
        
        if not os.path.exists(local_path):
            print(f"✗ Local file not found: {local_path}")
            return False
        
        try:
            subprocess.run([
                self.adb_path, "-s", self.device_id, "push", local_path, remote_path
            ], check=True, capture_output=True)
            print(f"✓ File pushed successfully to {remote_path}")
            return True
        except subprocess.CalledProcessError as e:
            print(f"✗ Failed to push file: {e}")
            return False
    
    def pull_file_from_device(self, remote_path, local_path):
        """Pull file from Android device"""
        print(f"\n[ADB] Pulling file: {remote_path} -> {local_path}")
        
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available")
            return False
        
        try:
            subprocess.run([
                self.adb_path, "-s", self.device_id, "pull", remote_path, local_path
            ], check=True, capture_output=True)
            print(f"✓ File pulled successfully to {local_path}")
            return True
        except subprocess.CalledProcessError as e:
            print(f"✗ Failed to pull file: {e}")
            return False
    
    def uninstall_apk(self, package_name=None):
        """Uninstall APK from device"""
        target_package = package_name or self.app_name
        if not target_package:
            print("✗ No package name provided for uninstall")
            return False
        
        print(f"\n[ADB] Uninstalling package: {target_package}")
        
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available")
            return False
        
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "uninstall", target_package
            ], capture_output=True, text=True, check=True)
            
            if "Success" in result.stdout:
                print("✓ APK uninstalled successfully")
                return True
            else:
                print(f"! Uninstall result: {result.stdout.strip()}")
                return False
                
        except subprocess.CalledProcessError as e:
            print(f"✗ APK uninstall failed: {e}")
            return False
    
    def get_process_list(self, filter_name=None):
        """Get list of running processes"""
        print(f"\n[ADB] Getting process list...")
        
        if not self.adb_path or not self.device_id:
            print("✗ ADB not available")
            return []
        
        try:
            # Use ps command to get process list
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps"
            ], capture_output=True, text=True, check=True)
            
            processes = []
            lines = result.stdout.strip().split('\n')[1:]  # Skip header
            
            for line in lines:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 9:
                        process_info = {
                            'user': parts[0],
                            'pid': parts[1],
                            'ppid': parts[2],
                            'vsize': parts[3],
                            'rss': parts[4],
                            'wchan': parts[5],
                            'pc': parts[6],
                            'name': ' '.join(parts[8:])
                        }
                        
                        # Filter by name if specified
                        if filter_name:
                            if filter_name.lower() in process_info['name'].lower():
                                processes.append(process_info)
                        else:
                            processes.append(process_info)
            
            # Save process list
            ps_file = self.output_dir / "process_list.txt"
            with open(ps_file, 'w') as f:
                f.write(result.stdout)
            
            print(f"✓ Found {len(processes)} processes")
            if filter_name:
                print(f"✓ Filtered {len(processes)} processes matching '{filter_name}'")
            print(f"✓ Process list saved to: {ps_file}")
            
            return processes
            
        except subprocess.CalledProcessError as e:
            print(f"✗ Failed to get process list: {e}")
            return []
    
    def run_frida_script(self, script_content, target_process=None):
        """Run Frida script against target process"""
        target = target_process or self.process_id or self.app_name
        if not target:
            print("✗ No target process specified for Frida")
            return False
        
        print(f"\n[FRIDA] Running script against: {target}")
        
        try:
            # Create temporary script file
            script_file = self.output_dir / "frida_script.js"
            with open(script_file, 'w') as f:
                f.write(script_content)
            
            # Run Frida
            cmd = ["frida", "-U", "-f" if isinstance(target, str) else "-p", str(target), "-l", str(script_file)]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            # Save Frida output
            frida_output_file = self.output_dir / f"frida_output_{target}.txt"
            with open(frida_output_file, 'w') as f:
                f.write(f"STDOUT:\n{result.stdout}\n\nSTDERR:\n{result.stderr}")
            
            print(f"✓ Frida script executed, output saved to: {frida_output_file}")
            return True
            
        except subprocess.TimeoutExpired:
            print("! Frida script execution timed out")
            return False
        except subprocess.CalledProcessError as e:
            print(f"✗ Frida script execution failed: {e}")
            return False
        except FileNotFoundError:
            print("✗ Frida not found. Please install frida-tools: pip install frida-tools")
            return False
    
    def run_objection_commands(self, commands):
        """Run objection commands"""
        if not self.app_name:
            print("✗ No app name specified for objection")
            return False
        
        print(f"\n[OBJECTION] Running commands against: {self.app_name}")
        
        try:
            # Create objection command file
            cmd_file = self.output_dir / "objection_commands.txt"
            with open(cmd_file, 'w') as f:
                f.write('\n'.join(commands))
            
            # Run objection
            result = subprocess.run([
                "objection", "-g", self.app_name, "explore", "-q", str(cmd_file)
            ], capture_output=True, text=True, timeout=60)
            
            # Save objection output
            objection_output_file = self.output_dir / f"objection_output_{self.app_name}.txt"
            with open(objection_output_file, 'w') as f:
                f.write(f"STDOUT:\n{result.stdout}\n\nSTDERR:\n{result.stderr}")
            
            print(f"✓ Objection commands executed, output saved to: {objection_output_file}")
            return True
            
        except subprocess.TimeoutExpired:
            print("! Objection execution timed out")
            return False
        except subprocess.CalledProcessError as e:
            print(f"✗ Objection execution failed: {e}")
            return False
        except FileNotFoundError:
            print("✗ Objection not found. Please install objection: pip install objection")
            return False
    
    def _setup_frida_server_optional(self):
        """Optional setup of Frida server"""
        print("\n[8] Setting up Frida server (optional)...")
        
        if not self.adb_path or not self.device_id:
            print("! Skipping Frida setup (ADB not available)")
            return
        
        # Check if frida-tools is installed
        try:
            subprocess.run(["frida", "--version"], check=True, capture_output=True)
            print("✓ Frida tools detected")
            
            # Try to setup Frida server
            frida_success = self.setup_frida_server()
            if frida_success:
                print("✓ Frida server ready for use")
            else:
                print("! Frida server setup incomplete - manual setup may be required")
                
        except (subprocess.CalledProcessError, FileNotFoundError):
            print("! Frida tools not installed or not in PATH")
            print("  Install with: pip install frida-tools")
    
    def _get_process_list(self):
        """Get and save process list"""
        print("\n[9] Getting process list...")
        
        # Get all processes
        all_processes = self.get_process_list()
        
        # Get processes related to our app if app_name is available
        if self.app_name:
            app_processes = self.get_process_list(filter_name=self.app_name)
            if app_processes:
                print(f"✓ Found {len(app_processes)} processes for {self.app_name}")
                for proc in app_processes:
                    print(f"  PID: {proc['pid']}, Name: {proc['name']}")
                    
                    # Auto-set process_id if not provided
                    if not self.process_id and len(app_processes) == 1:
                        self.process_id = int(app_processes[0]['pid'])
                        print(f"✓ Auto-detected PID: {self.process_id}")
