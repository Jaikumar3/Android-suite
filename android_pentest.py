#!/usr/bin/env python3
"""
Android Pentesting Automation Tool
Centralized class-based approach for Android pentesting automation
"""

import os
import sys
import shutil
import subprocess
import time
import json
import platform
import lzma
from pathlib import Path

try:
    import requests
except ImportError:
    requests = None

class AndroidPentester:
    """Main class for Android penetration testing automation"""
    
    def __init__(self, apk_path, app_name=None, process_id=None, device_id=None, output_dir="./output"):
        """
        Initialize the Android Pentester
        
        Args:
            apk_path (str): Path to the APK file
            app_name (str): Application package name or name
            process_id (int): Process ID of running application
            device_id (str): Specific Android device ID
            output_dir (str): Directory for output files
        """
        self.apk_path = apk_path
        self.app_name = app_name
        self.process_id = process_id
        self.device_id = device_id
        self.output_dir = Path(output_dir)
        
        # Create output directory
        self.output_dir.mkdir(exist_ok=True)
        
        # Tool paths (will be set during dependency check)
        self.adb_path = None
        self.aapt_path = None
        self.jadx_path = None
        
        # Perform silent tool check on initialization
        self._check_android_tools(silent=True)

    def _check_android_tools(self, silent=False):
        """Check for required Android tools and provide installation guidance
        
        Args:
            silent (bool): If True, only check tools without printing status
        """
        if not silent:
            print("\nChecking Android SDK tools...")
        
        # Check for ADB
        self.adb_path = shutil.which("adb")
        if not silent:
            if self.adb_path:
                print(f"âœ“ ADB found at: {self.adb_path}")
            else:
                print("âœ— ADB not found. Please install Android SDK Platform Tools")
                print("  Download from: https://developer.android.com/studio/releases/platform-tools")
        
        # Check for AAPT
        self.aapt_path = shutil.which("aapt")
        if not silent:
            if self.aapt_path:
                print(f"âœ“ AAPT found at: {self.aapt_path}")
            else:
                print("âœ— AAPT not found. Please install Android SDK Build Tools")
        
        # Check for JADX (optional)
        self.jadx_path = shutil.which("jadx")
        if not silent:
            if self.jadx_path:
                print(f"âœ“ JADX found at: {self.jadx_path}")
            else:
                print("! JADX not found (optional). Download from: https://github.com/skylot/jadx")

    def check_tools_verbose(self):
        """Check tools with verbose output - useful for installer/setup"""
        self._check_android_tools(silent=False)

    def _setup_adb_connection(self):
        """Setup ADB connection to Android device"""
        if not self.adb_path:
            return False
        
        try:
            # Start ADB server
            subprocess.run([self.adb_path, "start-server"], check=True, capture_output=True)
            
            # List connected devices
            result = subprocess.run([
                self.adb_path, "devices"
            ], capture_output=True, text=True, check=True)
            
            devices = []
            for line in result.stdout.split('\n')[1:]:
                if line.strip() and '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
            
            if not devices:
                return False
            
            if self.device_id and self.device_id not in devices:
                return False
            
            if not self.device_id:
                self.device_id = devices[0]
            
            return True
            
        except subprocess.CalledProcessError:
            return False

    def _collect_device_info(self):
        """Collect device information"""
        device_info = {}
        
        if not self.adb_path or not self.device_id:
            return device_info
        
        info_commands = {
            "android_version": ["getprop", "ro.build.version.release"],
            "sdk_version": ["getprop", "ro.build.version.sdk"],
            "device_model": ["getprop", "ro.product.model"],
            "device_brand": ["getprop", "ro.product.brand"],
            "architecture": ["getprop", "ro.product.cpu.abi"]
        }
        
        for key, cmd in info_commands.items():
            try:
                result = subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell"
                ] + cmd, capture_output=True, text=True, check=True)
                
                device_info[key] = result.stdout.strip()
                
            except subprocess.CalledProcessError:
                device_info[key] = "Unknown"
        
        return device_info

    def run_jadx_decompile(self, apk_path=None, output_dir=None, extra_args=None):
        """
        Run JADX CLI to decompile an APK using class context.
        Args:
            apk_path (str): Path to APK file (optional, uses self.apk_path if not provided)
            output_dir (str): Output directory for decompiled files (default: ./jadx_out)
            extra_args (list): Additional command-line arguments for JADX (optional)
        Returns:
            (success: bool, stdout: str, stderr: str, message: str)
        """
        apk_path = apk_path or self.apk_path
        if not apk_path or not os.path.exists(apk_path):
            return False, '', '', "[!] APK file not found or not specified."
        
        # Find jadx or jadx-cli in PATH
        jadx_path = shutil.which("jadx") or shutil.which("jadx-cli")
        if not jadx_path:
            return False, '', '', "[!] jadx or jadx-cli not found in PATH. Please install jadx (https://github.com/skylot/jadx) and add to PATH."
        
        output_dir = output_dir or os.path.join(os.path.dirname(apk_path), "jadx_out")
        os.makedirs(output_dir, exist_ok=True)
        
        cmd = [jadx_path, "-d", output_dir, apk_path]
        if extra_args:
            cmd.extend(extra_args)
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] JADX decompilation complete. Output in {output_dir}"
        except Exception as e:
            return False, '', str(e), f"[!] JADX decompilation failed: {e}"

    def run_frida_script_gen(self, apk_path=None, output_file=None, extra_args=None):
        """
        Run frida-script-gen tool from tools/frida-script-gen using class context.
        Args:
            apk_path (str): Path to APK file (optional, uses self.apk_path if not provided)
            output_file (str): Path to output file (optional)
            extra_args (list): Additional command-line arguments (optional)
        Returns:
            (success: bool, stdout: str, stderr: str, message: str)
        """
        script_path = os.path.join("tools", "frida-script-gen", "frida-script-gen.py")
        apk_file = apk_path or self.apk_path
        
        if not os.path.exists(script_path):
            return False, '', '', "[!] frida-script-gen not found. Please clone https://github.com/thecybersandeep/frida-script-gen into tools/."
        
        if not apk_file or not os.path.exists(apk_file):
            return False, '', '', "[!] APK file not found or not specified."
        
        cmd = [sys.executable, script_path, apk_file]
        if output_file:
            cmd += ["-o", output_file]
        if extra_args:
            cmd += extra_args
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            return True, result.stdout, result.stderr, "[+] frida-script-gen completed."
        except Exception as e:
            return False, '', str(e), f"[!] Error running frida-script-gen: {e}"

    def run_apk_components_inspector(self, apk_path=None):
        """
        Run apk-components-inspector on the given APK file using class context.
        Args:
            apk_path (str): Path to APK file (optional, uses self.apk_path if not provided)
        Returns a tuple (success: bool, stdout: str, stderr: str, message: str)
        """
        venv_py = os.path.join("tools", "apk-components-inspector", "venv", "Scripts" if os.name == "nt" else "bin", "python.exe" if os.name == "nt" else "python")
        inspector_py = os.path.join("tools", "apk-components-inspector", "apk-components-inspector.py")
        apk_path = apk_path or self.apk_path
        
        if not os.path.exists(venv_py) or not os.path.exists(inspector_py):
            return False, '', '', "[!] apk-components-inspector not found or not installed. Please run the installer first."
        
        try:
            result = subprocess.run([venv_py, inspector_py, apk_path], capture_output=True, text=True)
            return True, result.stdout, result.stderr, "[+] apk-components-inspector completed."
        except Exception as e:
            return False, '', str(e), f"[!] Error running apk-components-inspector: {e}"

    def run_apktool(self, apk_path=None, output_dir=None, extra_args=None):
        """Run apktool to decompile APK using class context. Returns (success: bool, stdout: str, stderr: str, message: str)"""
        apk_path = apk_path or self.apk_path
        apktool_cmd = "apktool.bat" if platform.system() == "Windows" else "apktool"
        apktool_path = shutil.which(apktool_cmd)
        
        if not apktool_path:
            return False, '', '', "[!] apktool not found in PATH. Please install it and ensure it's available."
        
        output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apktool_out"
        cmd = [apktool_path, "d", apk_path, "-o", output_dir, "-f"]
        if extra_args:
            cmd.extend(extra_args)
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] APK decompiled to: {output_dir}"
        except Exception as e:
            return False, '', str(e), f"[!] apktool failed: {e}"

    def run_apkleaks(self, apk_path=None, output_dir=None, extra_args=None):
        """Run APKLeaks on the APK using class context. Returns (success: bool, stdout: str, stderr: str, message: str)"""
        apk_path = apk_path or self.apk_path
        apkleaks_path = shutil.which("apkleaks")
        
        if not apkleaks_path:
            return False, '', '', "[!] apkleaks not found in PATH. Please install it (pip install apkleaks)."
        
        output_dir = output_dir or os.path.splitext(apk_path)[0] + "_apkleaks_out"
        os.makedirs(output_dir, exist_ok=True)
        
        cmd = [apkleaks_path, "-f", apk_path, "-o", output_dir]
        if extra_args:
            cmd.extend(extra_args)
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True, result.stdout, result.stderr, f"[+] APKLeaks results saved to: {output_dir}"
        except Exception as e:
            return False, '', str(e), f"[!] apkleaks failed: {e}"

    def list_installed_packages(self, device_id=None):
        """
        List all installed package names on the connected Android device using class context.
        Args:
            device_id (str): Device ID (optional, uses self.device_id if not provided)
        Returns a tuple (success: bool, packages: list, message: str)
        """
        adb_path = self.adb_path or shutil.which("adb")
        if not adb_path:
            return False, [], "[!] ADB not found in PATH. Please install Android SDK Platform Tools."
        
        device_id = device_id or self.device_id
        
        # Check if device is connected
        try:
            # First check if any devices are connected
            devices_result = subprocess.run([adb_path, "devices"], capture_output=True, text=True, check=True)
            connected_devices = []
            for line in devices_result.stdout.split('\n')[1:]:
                if line.strip() and '\tdevice' in line:
                    connected_devices.append(line.split('\t')[0])
            
            if not connected_devices:
                return False, [], "[!] No Android devices connected. Please connect a device and enable USB debugging."
            
            # If no specific device ID provided, use the first connected device
            if not device_id:
                device_id = connected_devices[0]
            elif device_id not in connected_devices:
                return False, [], f"[!] Device '{device_id}' not found. Connected devices: {', '.join(connected_devices)}"
                
        except subprocess.CalledProcessError as e:
            return False, [], f"[!] Failed to check connected devices: {e}"
        
        # Build command to list packages
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["shell", "pm", "list", "packages"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=30)
            packages = [line.replace("package:", "").strip() for line in result.stdout.splitlines() if line.strip()]
            
            if not packages:
                return False, [], "[!] No packages found on device. Device might not be properly connected."
            
            return True, packages, f"[+] Found {len(packages)} installed packages on device {device_id}"
            
        except subprocess.TimeoutExpired:
            return False, [], "[!] Timeout while listing packages. Device might be unresponsive."
        except subprocess.CalledProcessError as e:
            return False, [], f"[!] Failed to list packages: {e}"
        except Exception as e:
            return False, [], f"[!] Unexpected error: {e}"

    def extract_app_data_directory(self, package, dest_dir, device_id=None, use_compression=False):
        """
        Extract the /data/data/<package> directory from the device using adb (root required).
        Args:
            package (str): Package name to extract
            dest_dir (str): Destination directory for extracted data
            device_id (str): Device ID (optional)
            use_compression (bool): Use tar compression for large data (faster transfer)
        Returns (success: bool, message: str)
        """
        adb_path = self.adb_path or shutil.which("adb")
        if not adb_path:
            return False, "[!] adb not found in PATH. Please install platform-tools and add to PATH."
        
        if not package:
            return False, "[!] No package name provided."
        
        os.makedirs(dest_dir, exist_ok=True)
        device_id = device_id or self.device_id
        
        # Try to restart ADB daemon as root first
        try:
            root_cmd = [adb_path]
            if device_id:
                root_cmd += ["-s", device_id]
            root_cmd += ["root"]
            
            root_result = subprocess.run(root_cmd, capture_output=True, text=True, timeout=15)
            if root_result.returncode == 0:
                # Wait a moment for adb to restart
                time.sleep(2)
                # ADB root successful, we can try direct access
                use_root_access = True
            else:
                # ADB root failed, fall back to su method
                use_root_access = False
        except Exception:
            use_root_access = False
        
        if use_root_access:
            if use_compression:
                # Use tar compression for faster transfer of large data
                print("[*] Using compression for faster transfer...")
                copy_cmd = [adb_path]
                if device_id:
                    copy_cmd += ["-s", device_id]
                copy_cmd += ["shell", f"tar -czf /sdcard/{package}.tar.gz -C /data/data {package}"]
            else:
                # Try direct access with adb root
                copy_cmd = [adb_path]
                if device_id:
                    copy_cmd += ["-s", device_id]
                copy_cmd += ["shell", f"cp -r /data/data/{package} /sdcard/"]
            
            # Check app data size first to warn about large extractions
            size_cmd = [adb_path]
            if device_id:
                size_cmd += ["-s", device_id]
            size_cmd += ["shell", f"du -sh /data/data/{package} 2>/dev/null || echo 'Size check failed'"]
            
            try:
                size_result = subprocess.run(size_cmd, capture_output=True, text=True, timeout=10)
                if size_result.returncode == 0 and "Size check failed" not in size_result.stdout:
                    size_info = size_result.stdout.strip().split()[0] if size_result.stdout.strip() else "Unknown"
                    print(f"[*] App data size: {size_info}")
                    if any(unit in size_info.upper() for unit in ['G', 'GB']) or \
                       (any(unit in size_info.upper() for unit in ['M', 'MB']) and 
                        any(char.isdigit() for char in size_info) and 
                        int(''.join(filter(str.isdigit, size_info))) > 100):
                        print("[!] WARNING: Large app data detected. This may take several minutes.")
                        if not use_compression:
                            print("[*] TIP: Use compression option for faster transfer of large data.")
            except:
                pass  # Continue anyway if size check fails
        else:
            # Fall back to su method - first check if device supports su
            check_cmd = [adb_path]
            if device_id:
                check_cmd += ["-s", device_id]
            check_cmd += ["shell", "su", "-c", "echo 'root test'"]
            
            try:
                root_check = subprocess.run(check_cmd, capture_output=True, text=True, timeout=10)
                if root_check.returncode != 0:
                    return False, "[!] ROOT ACCESS REQUIRED: This feature requires a rooted Android device.\n" \
                                "The /data/data/ directory is protected and can only be accessed with root privileges.\n" \
                                "Please root your device or use an emulator with root access."
            except subprocess.TimeoutExpired:
                return False, "[!] ROOT CHECK TIMEOUT: Unable to verify root access. Device may not be rooted."
            except Exception:
                pass  # Continue anyway, let the actual pull command determine the result
            
            # Use su method
            copy_cmd = [adb_path]
            if device_id:
                copy_cmd += ["-s", device_id]
            copy_cmd += ["shell", "su", "-c", f"cp -r /data/data/{package} /sdcard/"]
        
        try:
            print("[*] Copying app data from protected directory...")
            print("[*] Maximum operation time: 10 minutes (will be killed if exceeded)")
            # First copy to accessible location (10 minute timeout max)
            copy_result = self._run_with_extended_timeout(copy_cmd, "copy", 600)
            if copy_result.returncode != 0:
                # Check for specific permission errors
                error_output = copy_result.stderr + copy_result.stdout
                if "Permission denied" in error_output:
                    return False, "[!] PERMISSION DENIED: Root access required to extract app data.\n" \
                                "Solution options:\n" \
                                "1. Root your Android device\n" \
                                "2. Use a rooted emulator (like Android x86 with SuperSU)\n" \
                                "3. Use 'adb backup' for non-rooted devices (limited data)"
                elif "No such file or directory" in error_output:
                    return False, f"[!] Package '{package}' not found or has no data directory.\n" \
                                f"Make sure the package is installed and has created data files."
                else:
                    return False, f"[!] Failed to copy app data with root: {error_output}"
            
            print("[*] Pulling app data to local machine...")
            print("[*] Maximum operation time: 10 minutes (will be killed if exceeded)")
            # Now pull from accessible location
            pull_cmd = [adb_path]
            if device_id:
                pull_cmd += ["-s", device_id]
            
            if use_compression:
                pull_cmd += ["pull", f"/sdcard/{package}.tar.gz", dest_dir]
            else:
                pull_cmd += ["pull", f"/sdcard/{package}", dest_dir]
            
            pull_result = self._run_with_extended_timeout(pull_cmd, "pull", 600)
            
            print("[*] Cleaning up temporary files...")
            # Clean up temporary copy
            cleanup_cmd = [adb_path]
            if device_id:
                cleanup_cmd += ["-s", device_id]
            
            if use_compression:
                cleanup_cmd += ["shell", "rm", "-f", f"/sdcard/{package}.tar.gz"]
            else:
                cleanup_cmd += ["shell", "rm", "-rf", f"/sdcard/{package}"]
            subprocess.run(cleanup_cmd, capture_output=True, text=True)
            
            if pull_result.returncode == 0:
                if use_compression:
                    # Extract the tar.gz file locally
                    print("[*] Extracting compressed data...")
                    import tarfile
                    tar_path = os.path.join(dest_dir, f"{package}.tar.gz")
                    try:
                        with tarfile.open(tar_path, 'r:gz') as tar:
                            tar.extractall(dest_dir)
                        os.remove(tar_path)  # Remove the tar.gz file after extraction
                        return True, f"[+] App data for '{package}' extracted to {dest_dir}\n" \
                                   f"[+] Used 'adb root' with compression for faster transfer."
                    except Exception as e:
                        return False, f"[!] Failed to extract compressed data: {e}"
                else:
                    return True, f"[+] App data for '{package}' extracted to {dest_dir}\n" \
                               f"[+] Used 'adb root' to access protected data."
            else:
                return False, f"[!] Failed to pull app data from device: {pull_result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "[!] TIMEOUT: Data extraction operation was aborted after exceeding time limits.\n" \
                        "This indicates extremely large app data or system issues:\n" \
                        "1. App data is too large (>1GB) - consider extracting specific subdirectories\n" \
                        "2. Device storage is full or corrupted\n" \
                        "3. USB connection is unstable\n" \
                        "4. Device performance issues\n" \
                        "RECOMMENDATION: Use 'adb backup' for very large apps or try compression option."
        except Exception as e:
            return False, f"[!] Unexpected error during extraction: {e}"

    def get_pid_for_package(self, package_name=None):
        """Get PID for a running package using adb. Returns list of (pid, process_name) tuples."""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = self.device_id
        package_name = package_name or self.app_name
        
        if not adb_path:
            return []
        
        try:
            cmd = [adb_path]
            if device_id:
                cmd += ["-s", device_id]
            cmd += ["shell", "ps"]
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            matches = []
            
            for line in result.stdout.splitlines():
                if package_name in line:
                    parts = line.split()
                    if len(parts) > 1:
                        pid = parts[1]
                        proc_name = parts[-1]
                        matches.append((pid, proc_name))
            
            return matches
        except Exception:
            return []

    def get_process_list(self):
        """Get list of running processes"""
        if not self.adb_path or not self.device_id:
            return []
        
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps"
            ], capture_output=True, text=True, check=True)
            
            processes = []
            lines = result.stdout.strip().split('\n')[1:]  # Skip header
            
            for line in lines:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 9:
                        process_info = {
                            'pid': parts[1],
                            'name': ' '.join(parts[8:])
                        }
                        processes.append(process_info)
            
            return processes
        except Exception:
            return []

    def get_logcat(self, filter_tag=None, save_to_file=None, lines=200):
        """Fetch logcat output from the device. Optionally filter by tag and save to file."""
        if not self.adb_path or not self.device_id:
            return None
        
        cmd = [self.adb_path, "-s", self.device_id, "logcat", "-d", "-t", str(lines)]
        if filter_tag:
            cmd += [f"*:{filter_tag}"]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            log_output = result.stdout
            
            if save_to_file:
                with open(save_to_file, "w", encoding="utf-8") as f:
                    f.write(log_output)
            
            return log_output
        except Exception:
            return None

    # ADB utility methods
    def adb_install_apk(self, apk_path, device_id=None):
        """Install APK via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["install", "-r", apk_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return "Success" in result.stdout
        except Exception:
            return False

    def adb_uninstall_apk(self, package_name, device_id=None):
        """Uninstall APK via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["uninstall", package_name]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return "Success" in result.stdout
        except Exception:
            return False

    def adb_push_file(self, local_path, remote_path, device_id=None):
        """Push file via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["push", local_path, remote_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True
        except Exception:
            return False

    def adb_pull_file(self, remote_path, local_path, device_id=None):
        """Pull file via ADB using class context"""
        adb_path = self.adb_path or shutil.which("adb")
        device_id = device_id or self.device_id
        
        if not adb_path:
            return False
        
        cmd = [adb_path]
        if device_id:
            cmd += ["-s", device_id]
        cmd += ["pull", remote_path, local_path]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return True
        except Exception:
            return False

    # Frida-related methods
    def get_available_frida_versions(self, max_versions=10):
        """Fetch available Frida versions from GitHub releases"""
        try:
            import json
            
            if not requests:
                return None
                
            print("[*] Fetching available Frida versions from GitHub...")
            url = "https://api.github.com/repos/frida/frida/releases"
            
            response = requests.get(url, timeout=10)
            if response.status_code != 200:
                return None
                
            releases = response.json()
            versions = []
            
            for release in releases[:max_versions]:
                if not release.get('prerelease', False):  # Skip pre-releases
                    version = release.get('tag_name', '').strip()
                    if version:
                        versions.append(version)
            
            return versions
            
        except Exception as e:
            print(f"[!] Failed to fetch Frida versions: {e}")
            return None

    def setup_frida_server_interactive(self, frida_server_path=None):
        """Interactive Frida server setup with version selection"""
        if not self.adb_path or not self.device_id:
            print("[!] ADB not available or no device connected")
            return False
        
        print("\n" + "="*60)
        print("ðŸ”§ FRIDA SERVER SETUP")
        print("="*60)
        
        # Get available versions from GitHub
        available_versions = self.get_available_frida_versions()
        
        if available_versions:
            print("\nðŸ“‹ Available Frida Versions:")
            print("-" * 40)
            for i, version in enumerate(available_versions, 1):
                print(f"  {i:2d}. {version}")
            
            print(f"  {len(available_versions)+1:2d}. Enter custom version")
            print(f"  {len(available_versions)+2:2d}. Cancel")
            
            while True:
                try:
                    choice = input(f"\n[?] Select version (1-{len(available_versions)+2}): ").strip()
                    
                    if not choice:
                        continue
                        
                    choice_num = int(choice)
                    
                    if 1 <= choice_num <= len(available_versions):
                        selected_version = available_versions[choice_num - 1]
                        break
                    elif choice_num == len(available_versions) + 1:
                        # Custom version
                        selected_version = input("[*] Enter custom Frida version (e.g., 16.2.2): ").strip()
                        if not selected_version:
                            print("[!] Invalid version. Please try again.")
                            continue
                        break
                    elif choice_num == len(available_versions) + 2:
                        # Cancel
                        print("[*] Setup cancelled.")
                        return False
                    else:
                        print(f"[!] Invalid choice. Please enter 1-{len(available_versions)+2}")
                        
                except ValueError:
                    print("[!] Invalid input. Please enter a number.")
                    continue
        else:
            print("[!] Could not fetch versions from GitHub. Manual input required.")
            selected_version = input("[*] Enter Frida version (e.g., 16.2.2): ").strip()
            if not selected_version:
                print("[!] No version specified. Aborting setup.")
                return False
        
        print(f"\n[*] Selected Frida version: {selected_version}")
        
        # Confirm setup
        confirm = input(f"[?] Install Frida {selected_version} on host and device? (y/n): ").strip().lower()
        if confirm not in ('y', 'yes'):
            print("[*] Setup cancelled.")
            return False
        
        # Proceed with setup
        return self.setup_frida_server(frida_server_path, selected_version)

    def setup_frida_server(self, frida_server_path=None, user_version=None):
        """Setup Frida server on Android device and host, using user-specified version for both."""
        if not self.adb_path or not self.device_id:
            return False
        
        try:
            # Use user-specified version if provided
            if not user_version:
                return False
            
            print(f"\n[*] Installing Frida {user_version} on host...")
            
            # Install frida (core package) of specified version on host
            try:
                result = subprocess.run([
                    sys.executable, "-m", "pip", "install", f"frida=={user_version}"
                ], check=True, capture_output=True, text=True)
                print(f"[+] Frida {user_version} installed on host")
            except subprocess.CalledProcessError as e:
                print(f"[!] Failed to install Frida: {e.stderr}")
                return False
            except Exception as e:
                print(f"[!] Failed to install Frida: {e}")
                return False
            
            # Default Frida server location
            if not frida_server_path:
                frida_server_path = "/data/local/tmp/frida-server"
            
            print(f"[*] Downloading and setting up Frida server {user_version} on device...")
            
            # Download and push correct frida-server to device
            if not self._download_and_push_frida_server(user_version, frida_server_path):
                return False
            
            print(f"[*] Starting Frida server {user_version} in background...")
            
            # Kill any existing Frida servers first for clean startup
            print("[*] Stopping any existing Frida servers...")
            subprocess.run([
                self.adb_path, "-s", self.device_id, "shell",
                "pkill -f frida-server 2>/dev/null || killall frida-server 2>/dev/null || true"
            ], capture_output=True, text=True, timeout=10)
            time.sleep(2)
            
            # Start Frida server in background with proper daemonization
            startup_success = False
            try:
                # Method 1: Use nohup with proper daemonization and input redirection
                print("[*] Attempting robust background startup with nohup...")
                start_cmd = [
                    self.adb_path, "-s", self.device_id, "shell",
                    f"nohup {frida_server_path} >/dev/null 2>&1 < /dev/null &"
                ]
                
                start_result = subprocess.run(start_cmd, capture_output=True, text=True, timeout=8)
                
                if start_result.returncode == 0:
                    print("[+] Frida server started with nohup")
                    startup_success = True
                else:
                    # Method 2: Try with screen session (if available)
                    print("[*] Trying screen session method...")
                    screen_cmd = [
                        self.adb_path, "-s", self.device_id, "shell",
                        f"screen -dmS frida_session {frida_server_path} 2>/dev/null || ({frida_server_path} </dev/null >/dev/null 2>&1 &)"
                    ]
                    screen_result = subprocess.run(screen_cmd, capture_output=True, text=True, timeout=8)
                    if screen_result.returncode == 0:
                        print("[+] Frida server started with screen session")
                        startup_success = True
                
                # Method 3: Fallback to simple background execution
                if not startup_success:
                    print("[*] Using fallback background execution...")
                    fallback_cmd = [
                        self.adb_path, "-s", self.device_id, "shell",
                        f"({frida_server_path} &) && sleep 1"
                    ]
                    subprocess.run(fallback_cmd, capture_output=True, text=True, timeout=10)
                    print("[+] Frida server started with fallback method")
                    startup_success = True
                
            except subprocess.TimeoutExpired:
                print("[+] Frida server startup completed (background process)")
                startup_success = True
            except Exception as e:
                print(f"[!] Warning during startup: {e}")
                startup_success = False
            
            # Give the server time to initialize properly
            print("[*] Waiting for Frida server to initialize...")
            time.sleep(5)
            
            # Comprehensive verification with multiple checks
            for attempt in range(4):  # Increased attempts for better reliability
                print(f"[*] Verifying Frida server status (attempt {attempt + 1}/4)...")
                
                # Check 1: Process list using ps command
                try:
                    ps_result = subprocess.run([
                        self.adb_path, "-s", self.device_id, "shell", 
                        "ps | grep frida-server || ps -ef | grep frida-server"
                    ], capture_output=True, text=True, timeout=15)
                    
                    if ps_result.stdout.strip():
                        # Extract PID for confirmation
                        lines = ps_result.stdout.strip().split('\n')
                        frida_processes = []
                        for line in lines:
                            if 'frida-server' in line and 'grep' not in line:
                                parts = line.split()
                                if len(parts) >= 2:
                                    pid = parts[1] if len(parts) > 1 else parts[0]
                                    frida_processes.append(pid)
                        
                        if frida_processes:
                            print(f"[+] âœ“ Frida server {user_version} is running on device!")
                            print(f"[+] âœ“ Process ID(s): {', '.join(frida_processes)}")
                            
                            # Additional verification: Check if port is listening
                            port_check = subprocess.run([
                                self.adb_path, "-s", self.device_id, "shell",
                                "netstat -tuln 2>/dev/null | grep 27042 || ss -tuln 2>/dev/null | grep 27042 || lsof -i :27042 2>/dev/null"
                            ], capture_output=True, text=True, timeout=10)
                            
                            if "27042" in port_check.stdout:
                                print(f"[+] âœ“ Frida server is listening on port 27042")
                            
                            print(f"[+] âœ“ Frida server is running in background - you can continue with other activities")
                            print(f"[*] Server location: {frida_server_path}")
                            print(f"[*] To stop the server, use: adb shell pkill frida-server")
                            print(f"[*] Or use option 10 in the main menu to stop Frida")
                            print(f"[+] âœ“ Frida setup completed successfully!")
                            return True
                except Exception as e:
                    print(f"[!] Error during process check: {e}")
                
                # Check 2: Try to connect via frida-ps test (if frida is available locally)
                if attempt == 1:  # Only try this once to avoid spam
                    try:
                        print("[*] Testing Frida connection...")
                        # This will test if frida can connect to the server
                        test_result = subprocess.run([
                            "python", "-c", 
                            f"import frida; d = frida.get_device('{self.device_id}'); print('Connected to:', d)"
                        ], capture_output=True, text=True, timeout=10)
                        
                        if test_result.returncode == 0 and "Connected to:" in test_result.stdout:
                            print("[+] âœ“ Frida client can connect to server successfully")
                            print(f"[+] âœ“ Frida setup completed successfully!")
                            return True
                    except Exception:
                        pass  # Continue with other verification methods
                
                if attempt < 3:  # Don't sleep on the last attempt
                    print("[*] Server not fully ready yet, waiting...")
                    time.sleep(4)  # Increased wait time
            
            # Final comprehensive verification
            print("[*] Performing final comprehensive server verification...")
            
            verification_passed = False
            
            try:
                # Check 1: Network port listening
                print("[*] Checking if Frida server port is active...")
                netstat_result = subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell", 
                    "netstat -tuln 2>/dev/null | grep 27042 || ss -tuln 2>/dev/null | grep 27042 || lsof -i :27042 2>/dev/null"
                ], capture_output=True, text=True, timeout=15)
                
                if "27042" in netstat_result.stdout:
                    print(f"[+] âœ“ Frida server is listening on port 27042")
                    verification_passed = True
                
                # Check 2: Alternative process check
                if not verification_passed:
                    print("[*] Checking for Frida processes with alternative method...")
                    alt_ps_result = subprocess.run([
                        self.adb_path, "-s", self.device_id, "shell",
                        "pgrep frida-server 2>/dev/null || pidof frida-server 2>/dev/null || ps aux | grep '[f]rida-server'"
                    ], capture_output=True, text=True, timeout=15)
                    
                    if alt_ps_result.stdout.strip():
                        print(f"[+] âœ“ Frida server process found: {alt_ps_result.stdout.strip()}")
                        verification_passed = True
                
                # Check 3: File system check
                if not verification_passed:
                    print("[*] Verifying server binary is executable...")
                    file_check = subprocess.run([
                        self.adb_path, "-s", self.device_id, "shell",
                        f"ls -la {frida_server_path} 2>/dev/null"
                    ], capture_output=True, text=True, timeout=10)
                    
                    if file_check.returncode == 0 and 'x' in file_check.stdout:
                        print(f"[+] âœ“ Frida server binary is properly installed and executable")
                
                if verification_passed:
                    print(f"[+] âœ“ Frida server {user_version} verified and running in background!")
                    print(f"[+] âœ“ You can now continue with other activities")
                    print(f"[*] Server location: {frida_server_path}")
                    print(f"[*] To stop the server: adb shell pkill frida-server")
                    print(f"[*] Or use option 10 in the main menu")
                    print(f"[+] âœ“ Frida setup completed successfully!")
                    return True
                else:
                    # Server status uncertain but likely running
                    print("[!] âš ï¸  Frida server status uncertain but likely running")
                    print("[*] The server startup commands were executed successfully")
                    print("[*] Some Android versions limit process visibility")
                    print("[*] Try connecting with Frida tools to verify functionality")
                    print(f"[*] Server location: {frida_server_path}")
                    print(f"[*] If needed, restart with: adb shell {frida_server_path} &")
                    return True  # Return True since startup was attempted successfully
                    
            except Exception as e:
                print(f"[!] Error during final verification: {e}")
                print("[*] Frida server startup was attempted - it may still be running")
                return True  # Return True since we attempted startup
            
        except Exception as e:
            print(f"[!] Frida setup failed: {e}")
            return False

    def _download_and_push_frida_server(self, host_version, frida_server_path):
        """Download the correct frida-server for the device arch and push to device"""
        if not requests:
            print("[!] Requests library not available. Cannot download Frida server.")
            return False
        
        # Get device architecture
        try:
            print("[*] Detecting device architecture...")
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "getprop", "ro.product.cpu.abi"
            ], capture_output=True, text=True, check=True)
            arch = result.stdout.strip()
            print(f"[*] Device architecture: {arch}")
        except Exception as e:
            print(f"[!] Failed to detect device architecture: {e}")
            return False
        
        # Map arch to frida-server asset name
        arch_map = {
            "arm64-v8a": "android-arm64",
            "armeabi-v7a": "android-arm",
            "x86_64": "android-x86_64",
            "x86": "android-x86"
        }
        
        asset_arch = arch_map.get(arch)
        if not asset_arch:
            print(f"[!] Unsupported architecture: {arch}")
            print(f"[*] Supported architectures: {list(arch_map.keys())}")
            return False
        
        print(f"[*] Mapped to Frida architecture: {asset_arch}")
        
        # Download frida-server from GitHub
        github_url = f"https://github.com/frida/frida/releases/download/{host_version}/frida-server-{host_version}-{asset_arch}.xz"
        print(f"[*] Downloading Frida server from: {github_url}")
        
        try:
            r = requests.get(github_url, stream=True)
            if r.status_code != 200:
                print(f"[!] Failed to download Frida server (HTTP {r.status_code})")
                print(f"[*] URL: {github_url}")
                print(f"[*] This version/architecture combination may not exist")
                return False
            
            # Get total file size for progress
            total_size = int(r.headers.get('content-length', 0))
            
            # Save to temp file
            temp_xz = Path("./frida-server.xz")
            print(f"[*] Saving compressed file: {temp_xz}")
            
            downloaded = 0
            with open(temp_xz, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            percent = (downloaded / total_size) * 100
                            print(f"\r[*] Download progress: {percent:.1f}% ({downloaded}/{total_size} bytes)", end="", flush=True)
            
            print("\n[+] Download completed")
            
            # Extract xz
            print("[*] Extracting compressed file...")
            temp_bin = Path("./frida-server")
            try:
                with lzma.open(temp_xz, "rb") as f_in, open(temp_bin, "wb") as f_out:
                    shutil.copyfileobj(f_in, f_out)
                print("[+] Extraction completed")
            except Exception as e:
                print(f"[!] Failed to extract: {e}")
                return False
            
            temp_xz.unlink()  # Remove compressed file
            
            # Push to device
            print(f"[*] Pushing Frida server to device: {frida_server_path}")
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "push", str(temp_bin), frida_server_path
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                print(f"[!] Failed to push to device: {result.stderr}")
                return False
            
            print("[+] Frida server pushed to device")
            
            # Set executable permissions
            print("[*] Setting executable permissions...")
            subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "chmod", "755", frida_server_path
            ], check=True)
            
            print("[+] Permissions set")
            
            temp_bin.unlink()  # Remove local file
            return True
            
        except Exception as e:
            print(f"[!] Failed to download/setup Frida server: {e}")
            return False

    def stop_frida_server(self):
        """Stop/kill the Frida server process on the device."""
        if not self.adb_path or not self.device_id:
            return False
        
        try:
            # Use pkill if available, otherwise fallback to kill
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "pkill frida-server"
            ], capture_output=True, text=True)
            
            # Check if process still running
            check = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "ps | grep frida-server"
            ], capture_output=True, text=True)
            
            if check.stdout.strip():
                # Try killall as fallback
                subprocess.run([
                    self.adb_path, "-s", self.device_id, "shell", "killall frida-server"
                ], capture_output=True, text=True)
            
            return True
        except Exception:
            return False

    def menu_stop_frida_server(self):
        """Menu wrapper to stop Frida server with user feedback."""
        result = self.stop_frida_server()
        if result:
            print("[+] Frida server stopped successfully.")
        else:
            print("[!] Failed to stop Frida server or it was not running.")

    def run_fridump(self, output_dir=None, extra_args=None):
        """Run fridump to dump APK memory using Frida. Handles subprocess call internally."""
        if not self.app_name:
            return False
        
        script_path = os.path.join("tools", "fridump", "fridump.py")
        if not os.path.exists(script_path):
            return False
        
        output_dir = output_dir or os.path.join(str(self.output_dir), "fridump")
        os.makedirs(output_dir, exist_ok=True)
        
        cmd = [sys.executable, script_path, "-U", "-n", self.app_name, "-o", output_dir]
        if extra_args:
            cmd.extend(extra_args)
        
        try:
            subprocess.run(cmd, check=True)
            return True
        except Exception:
            return False

    def install_dependencies(self):
        """Install and setup required dependencies for Android pentesting"""
        print("For installation, please use the separate installer script:")
        print("  python installer.py --standard    # Standard installation")
        print("  python installer.py --full        # Full installation with all tools")
        print("  python installer.py --minimal     # Minimal installation")
        print("  python installer.py --frida-only  # Frida tools only")
        print("  python installer.py --verify-only # Verify existing installation")
        print("")
        print("Checking existing tools...")
        
        # Check for Android SDK tools
        self._check_android_tools()

    def run_mobapp_storage_inspector(self):
        """
        Launch MobApp-Storage-Inspector.jar GUI. No APK path or arguments needed.
        Returns a tuple (success: bool, stdout: str, stderr: str, message: str)
        """
        jar_path = ".\\tools\\MobApp-Storage-Inspector.jar"
        if not os.path.exists(jar_path):
            return False, '', '', "[!] MobApp-Storage-Inspector.jar not found in ./tools. Download it and place in the tools directory."
        
        # Try to find the best Java executable available
        java_candidates = ["java", "java.exe"]
        
        # Add common Java installation paths for Windows
        java_candidates.extend([
            "C:\\Program Files\\Java\\jdk-24\\bin\\java.exe",
            "C:\\Program Files\\Java\\jdk-21\\bin\\java.exe", 
            "C:\\Program Files\\Java\\jdk-17\\bin\\java.exe",
            "C:\\Program Files\\Eclipse Adoptium\\jdk-24.0.1.9-hotspot\\bin\\java.exe",
            "C:\\Program Files\\Eclipse Adoptium\\jdk-21.0.4.7-hotspot\\bin\\java.exe",
            "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.12.7-hotspot\\bin\\java.exe"
        ])
        
        java_exe = None
        for candidate in java_candidates:
            try:
                # Test if this Java works and get version
                result = subprocess.run([candidate, "-version"], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    java_exe = candidate
                    break
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        if not java_exe:
            return False, '', '', "[!] Java is not installed or not in PATH. Please install Java 17+ to run MobApp-Storage-Inspector."
        
        try:
            # Launch GUI application in background without timeout
            # Use Popen to start the process and let it run independently
            process = subprocess.Popen(
                [java_exe, "-jar", jar_path], 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                text=True,
                creationflags=subprocess.CREATE_NEW_CONSOLE if os.name == 'nt' else 0
            )
            
            # Give it a moment to start and check if it's still running
            time.sleep(2)
            poll_result = process.poll()
            
            if poll_result is None:
                # Process is still running (good for GUI)
                return True, "", "", f"[+] MobApp-Storage-Inspector GUI launched successfully (PID: {process.pid}). Running in background."
            elif poll_result == 0:
                # Process exited successfully (might be normal for some GUI apps)
                return True, "", "", "[+] MobApp-Storage-Inspector GUI launched successfully."
            else:
                # Process exited with error
                stdout, stderr = process.communicate(timeout=5)
                error_output = stderr + stdout
                
                if "UnsupportedClassVersionError" in error_output or "class file version" in error_output:
                    error_msg = "[!] Java version incompatibility: MobApp-Storage-Inspector requires Java 17 or higher.\n"
                    error_msg += f"Using Java: {java_exe}\n"
                    error_msg += "Please ensure you have Java 17+ installed and properly configured.\n"
                    error_msg += "Download from: https://adoptium.net/ or https://www.oracle.com/java/technologies/downloads/"
                    return False, stdout, stderr, error_msg
                
                # Provide detailed error information for other errors
                error_msg = f"[!] MobApp-Storage-Inspector failed to launch (exit code {poll_result})"
                error_msg += f"\nUsing Java: {java_exe}"
                if stderr:
                    error_msg += f"\nError output: {stderr.strip()}"
                if stdout:
                    error_msg += f"\nStandard output: {stdout.strip()}"
                return False, stdout, stderr, error_msg
                
        except subprocess.TimeoutExpired:
            # This should rarely happen now since we're not using timeout on main launch
            return False, '', '', "[!] MobApp-Storage-Inspector startup check timed out. The GUI may be starting slowly."
        except Exception as e:
            return False, '', str(e), f"[!] MobApp-Storage-Inspector failed to launch: {e}"

    def setup_emulator_with_playstore_and_root(self):
        """Guide user through setting up an Android emulator with Play Store and root access"""
        print("\n" + "="*70)
        print("ðŸ¤– ANDROID EMULATOR SETUP - PLAY STORE + ROOT")
        print("="*70)
        
        print("\nðŸ“‹ RECOMMENDED SETUP STEPS:")
        print("-" * 50)
        print("1ï¸âƒ£  CREATE AVD WITH PLAY STORE:")
        print("   â€¢ Open Android Studio > Tools > AVD Manager")
        print("   â€¢ Create Virtual Device > Choose Pixel 6/7")
        print("   â€¢ Select system image with ðŸ›ï¸ Play Store icon")
        print("   â€¢ Use x86_64 architecture (faster performance)")
        print("   â€¢ Recommended: Android 11 (API 30) or 12 (API 31)")
        
        print("\n2ï¸âƒ£  START WITH ROOT ACCESS:")
        print("   â€¢ emulator -list-avds")
        print("   â€¢ emulator -avd <YOUR_AVD_NAME> -writable-system")
        
        print("\n3ï¸âƒ£  ENABLE ROOT:")
        print("   â€¢ adb root")
        print("   â€¢ adb remount")
        
        print("\n4ï¸âƒ£  VERIFY:")
        print("   â€¢ Use option 2 to check emulator status")
        print("   â€¢ Play Store should be in app drawer")
        
        # Check current status if emulator is running
        if self.adb_path and self.device_id:
            print("\n[*] Checking current emulator...")
            is_emulator, has_root, is_writable, msg = self.check_emulator_root_status()
            if is_emulator:
                playstore = self._check_playstore_availability()
                print(f"ðŸ¤– Emulator: âœ…")
                print(f"ðŸ” Root: {'âœ…' if has_root else 'âŒ'}")
                print(f"ðŸ“ Writable: {'âœ…' if is_writable else 'âŒ'}")
                print(f"ðŸ›ï¸ Play Store: {'âœ…' if playstore else 'âŒ'}")
                
                if has_root and is_writable and playstore:
                    print("\nðŸŽ‰ PERFECT! Your emulator is ready for pentesting!")
        
        return True

    def _check_playstore_availability(self):
        """Check if Google Play Store is available"""
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell",
                "pm list packages | grep com.android.vending"
            ], capture_output=True, text=True, timeout=10)
            return "com.android.vending" in result.stdout
        except:
            return False

    def check_emulator_root_status(self):
        """
        Check if the connected emulator has root access and writable system partition.
        Returns a tuple (is_emulator: bool, has_root: bool, is_writable: bool, message: str)
        """
        if not self.adb_path or not self.device_id:
            return False, False, False, "[!] ADB not available or no device connected"
        
        try:
            # Check if device is an emulator
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell", "getprop", "ro.kernel.qemu"
            ], capture_output=True, text=True, check=True, timeout=10)
            
            is_emulator = "1" in result.stdout.strip()
            
            if not is_emulator:
                return False, False, False, "[*] Device is not an emulator (physical device detected)"
            
            # Check root access
            has_root = False
            try:
                root_result = subprocess.run([
                    self.adb_path, "-s", self.device_id, "root"
                ], capture_output=True, text=True, timeout=15)
                
                if root_result.returncode == 0:
                    # Wait for ADB to restart after root
                    time.sleep(3)
                    has_root = True
                else:
                    # Try su method
                    su_result = subprocess.run([
                        self.adb_path, "-s", self.device_id, "shell", "su", "-c", "id"
                    ], capture_output=True, text=True, timeout=10)
                    has_root = su_result.returncode == 0 and "uid=0" in su_result.stdout
            except subprocess.TimeoutExpired:
                has_root = False
            
            # Check if system partition is writable
            is_writable = False
            if has_root:
                try:
                    # Try to remount system as writable
                    remount_result = subprocess.run([
                        self.adb_path, "-s", self.device_id, "remount"
                    ], capture_output=True, text=True, timeout=10)
                    
                    # Test writing to system
                    test_result = subprocess.run([
                        self.adb_path, "-s", self.device_id, "shell", 
                        "touch", "/system/.pentest_write_test", "2>/dev/null", "&&", 
                        "rm", "/system/.pentest_write_test", "2>/dev/null", "&&", 
                        "echo", "writable"
                    ], capture_output=True, text=True, timeout=10)
                    
                    is_writable = "writable" in test_result.stdout
                except subprocess.TimeoutExpired:
                    is_writable = False
            
            # Generate status message
            status_parts = []
            status_parts.append(f"[+] Emulator detected: {self.device_id}")
            status_parts.append(f"[{'+' if has_root else '!'}] Root access: {'Available' if has_root else 'Not available'}")
            status_parts.append(f"[{'+' if is_writable else '!'}] System writable: {'Yes' if is_writable else 'No'}")
            
            if not has_root:
                status_parts.append("[*] TIP: Start emulator with: emulator -avd <name> -writable-system")
                status_parts.append("[*] Then run: adb root && adb remount")
            elif not is_writable:
                status_parts.append("[*] TIP: Run 'adb remount' to make system writable")
                status_parts.append("[*] Or restart emulator with -writable-system flag")
            
            message = "\n".join(status_parts)
            return is_emulator, has_root, is_writable, message
            
        except Exception as e:
            return False, False, False, f"[!] Error checking emulator status: {e}"

    def setup_burp_certificate(self, burp_cert_path=None, device_id=None):
        """
        Automate Burp Suite CA certificate extraction, conversion, and installation to Android device/emulator
        
        Args:
            burp_cert_path: Path to Burp certificate file (DER format). If None, will guide user to export it.
            device_id: Android device/emulator ID. If None, will use first available device.
        """
        print("[*] Setting up Burp Suite CA certificate for Android...")
        
        try:
            # Use provided device_id or the instance's device_id
            target_device = device_id or self.device_id
            
            # Check if ADB is available
            if not self.adb_path:
                print("[!] ADB not found. Please install Android SDK tools first.")
                return False
            
            # Check if OpenSSL is available (needed for certificate conversion)
            openssl_available = self._check_openssl()
            if not openssl_available:
                print("[!] OpenSSL not found. Installing/configuring OpenSSL...")
                if not self._install_openssl():
                    print("[!] Failed to install OpenSSL. Manual certificate conversion required.")
                    return False
            
            # Get connected devices
            devices = self._get_connected_devices()
            if not devices:
                print("[!] No Android devices/emulators connected.")
                print("[*] Please start an emulator or connect a device with USB debugging enabled.")
                return False
            
            # Select target device
            if target_device and target_device not in devices:
                print(f"[!] Device {target_device} not found in connected devices: {devices}")
                return False
            elif not target_device:
                target_device = devices[0]
            
            print(f"[*] Target device: {target_device}")
            
            # Handle Burp certificate
            if not burp_cert_path:
                burp_cert_path = self._guide_burp_cert_export()
                if not burp_cert_path:
                    return False
            
            if not os.path.exists(burp_cert_path):
                print(f"[!] Burp certificate file not found: {burp_cert_path}")
                return False
            
            # Convert certificate to Android format
            android_cert_path = self._convert_burp_cert_to_android(burp_cert_path)
            if not android_cert_path:
                return False
            
            # Install certificate to Android device
            success = self._install_cert_to_android(target_device, android_cert_path)
            
            if success:
                print("[+] Burp certificate successfully installed to Android device!")
                print("[*] You can now intercept HTTPS traffic from apps on this device.")
                print("[*] Configure your device to use Burp as proxy (usually 192.168.1.X:8080)")
            
            return success
            
        except Exception as e:
            print(f"[!] Error setting up Burp certificate: {str(e)}")
            return False
    
    def _check_openssl(self):
        """Check if OpenSSL is available"""
        try:
            result = subprocess.run(['openssl', 'version'], 
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except:
            return False
    
    def _install_openssl(self):
        """Install OpenSSL on Windows (recommend Chocolatey or download from official site)"""
        system = platform.system().lower()
        if system != "windows":
            print("[*] Please install OpenSSL using your system package manager.")
            return False
        
        print("[*] Installing OpenSSL for Windows...")
        print("[*] Recommended: Install via Chocolatey for easier management:")
        print("    1. Install Chocolatey (if not installed):")
        print("       Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))")
        print("    2. Install OpenSSL: choco install openssl")
        print("[*] Alternative: Manual installation (will download installer)...")
        
        choice = input("[*] Use Chocolatey installation? (y/n, default: y): ").strip().lower()
        if choice in ('', 'y', 'yes'):
            print("[*] Please run the following commands in an Administrator PowerShell:")
            print("    choco install openssl")
            print("[*] After installation, restart your terminal/IDE to refresh PATH.")
            return True
        
        try:
            # Download OpenSSL for Windows
            openssl_url = "https://slproweb.com/download/Win64OpenSSL_Light-3_5_1.msi"
            tools_dir = Path("./tools")
            tools_dir.mkdir(exist_ok=True)
            openssl_installer = tools_dir / "openssl_installer.exe"
            
            print("[*] Downloading OpenSSL installer...")
            
            if requests:
                response = requests.get(openssl_url, stream=True)
                response.raise_for_status()
                
                with open(openssl_installer, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)
            else:
                print("[!] Requests library not available. Please install OpenSSL manually.")
                return False
            
            print("[!] OpenSSL installer downloaded. Please run it manually with admin privileges.")
            print(f"[*] Installer location: {openssl_installer}")
            print("[*] After installation, add OpenSSL to your PATH or use the full path.")
            
            return True
            
        except Exception as e:
            print(f"[!] Failed to download OpenSSL installer: {str(e)}")
            return False
    
    def _get_connected_devices(self):
        """Get list of connected Android devices/emulators"""
        try:
            cmd = [self.adb_path, 'devices']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                return []
            
            devices = []
            lines = result.stdout.strip().split('\n')[1:]  # Skip header
            for line in lines:
                if line.strip() and '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
            
            return devices
            
        except Exception as e:
            print(f"[!] Error getting connected devices: {str(e)}")
            return []
    
    def _guide_burp_cert_export(self):
        """Guide user through exporting Burp certificate"""
        print("[*] Burp Suite certificate export required:")
        print("    1. Open Burp Suite")
        print("    2. Go to Proxy > Options")
        print("    3. In 'Proxy Listeners', select your listener and click 'Import/export CA certificate'")
        print("    4. Choose 'Export > Certificate in DER format'")
        print("    5. Save as 'burp_cert.der' in your downloads or a known location")
        
        while True:
            cert_path = input("\nEnter the path to your exported Burp certificate (DER format): ").strip()
            if not cert_path:
                continue
                
            cert_path = Path(cert_path)
            if cert_path.exists():
                return str(cert_path)
            else:
                print(f"[!] File not found: {cert_path}")
                retry = input("Try again? (y/n): ").strip().lower()
                if retry != 'y':
                    return None
    
    def _convert_burp_cert_to_android(self, burp_cert_path):
        """Convert Burp certificate from DER to Android-compatible PEM format with proper naming"""
        try:
            print("[*] Converting Burp certificate to Android format...")
            
            # Create tools directory for temporary files
            tools_dir = Path("./tools")
            tools_dir.mkdir(exist_ok=True)
            
            # Convert DER to PEM using OpenSSL
            pem_path = tools_dir / "burp_cert.pem"
            
            openssl_cmd = [
                'openssl', 'x509', 
                '-inform', 'DER', 
                '-in', str(burp_cert_path),
                '-out', str(pem_path),
                '-outform', 'PEM'
            ]
            
            result = subprocess.run(openssl_cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                print(f"[!] OpenSSL conversion failed: {result.stderr}")
                return None
            
            # Get certificate hash for Android naming
            hash_cmd = ['openssl', 'x509', '-inform', 'PEM', '-subject_hash_old', '-in', str(pem_path), '-noout']
            hash_result = subprocess.run(hash_cmd, capture_output=True, text=True, timeout=30)
            
            if hash_result.returncode != 0:
                print(f"[!] Failed to get certificate hash: {hash_result.stderr}")
                return None
            
            cert_hash = hash_result.stdout.strip()
            android_cert_path = tools_dir / f"{cert_hash}.0"
            
            # Copy PEM to properly named file for Android
            shutil.copy2(pem_path, android_cert_path)
            
            print(f"[+] Certificate converted and saved as: {android_cert_path}")
            return str(android_cert_path)
            
        except Exception as e:
            print(f"[!] Error converting certificate: {str(e)}")
            return None
    
    def _install_cert_to_android(self, device_id, cert_path):
        """Install certificate to Android device system certificate store"""
        try:
            print(f"[*] Installing certificate to device {device_id}...")
            
            # Check if device is rooted and has writable system
            check_cmd = [self.adb_path, '-s', device_id, 'shell', 'su', '-c', 'mount | grep system']
            result = subprocess.run(check_cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                print("[!] Device appears to be non-rooted or su access denied.")
                print("[*] Attempting user certificate installation instead...")
                return self._install_cert_user_store(device_id, cert_path)
            
            # Push certificate to device
            device_cert_path = f"/sdcard/{os.path.basename(cert_path)}"
            push_cmd = [self.adb_path, '-s', device_id, 'push', cert_path, device_cert_path]
            
            result = subprocess.run(push_cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                print(f"[!] Failed to push certificate: {result.stderr}")
                return False
            
            # Mount system as writable
            mount_cmd = [self.adb_path, '-s', device_id, 'shell', 'su', '-c', 'mount -o rw,remount /system']
            subprocess.run(mount_cmd, capture_output=True, text=True, timeout=30)
            
            # Copy certificate to system store
            system_cert_path = f"/system/etc/security/cacerts/{os.path.basename(cert_path)}"
            copy_cmd = [self.adb_path, '-s', device_id, 'shell', 'su', '-c', f'cp {device_cert_path} {system_cert_path}']
            
            result = subprocess.run(copy_cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                print(f"[!] Failed to copy certificate to system store: {result.stderr}")
                return False
            
            # Set proper permissions
            chmod_cmd = [self.adb_path, '-s', device_id, 'shell', 'su', '-c', f'chmod 644 {system_cert_path}']
            subprocess.run(chmod_cmd, capture_output=True, text=True, timeout=30)
            
            # Clean up temporary file
            cleanup_cmd = [self.adb_path, '-s', device_id, 'shell', 'rm', device_cert_path]
            subprocess.run(cleanup_cmd, capture_output=True, text=True, timeout=30)
            
            # Remount system as read-only
            remount_cmd = [self.adb_path, '-s', device_id, 'shell', 'su', '-c', 'mount -o ro,remount /system']
            subprocess.run(remount_cmd, capture_output=True, text=True, timeout=30)
            
            print("[+] Certificate installed to system certificate store.")
            print("[*] You may need to reboot the device for changes to take effect.")
            
            return True
            
        except Exception as e:
            print(f"[!] Error installing certificate: {str(e)}")
            return False
    
    def _install_cert_user_store(self, device_id, cert_path):
        """Install certificate to user certificate store (for non-rooted devices)"""
        try:
            print("[*] Installing certificate to user certificate store...")
            
            # Push certificate to device
            device_cert_path = f"/sdcard/{os.path.basename(cert_path)}"
            push_cmd = [self.adb_path, '-s', device_id, 'push', cert_path, device_cert_path]
            
            result = subprocess.run(push_cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                print(f"[!] Failed to push certificate: {result.stderr}")
                return False
            
            print("[!] Certificate pushed to device. Manual installation required:")
            print("    1. On your Android device, go to Settings > Security > Encryption & credentials")
            print("    2. Tap 'Install a certificate' > 'CA certificate'")
            print(f"    3. Navigate to and select the certificate file: {device_cert_path}")
            print("    4. Give it a name (e.g., 'Burp Suite CA') and tap OK")
            print("[!] Note: User certificates may not work with all apps due to Network Security Config")
            
            return True
            
        except Exception as e:
            print(f"[!] Error installing certificate to user store: {str(e)}")
            return False

    def _run_with_extended_timeout(self, cmd, operation_name, initial_timeout):
        """
        Run a command with extended timeout capability - asks user if they want more time
        Args:
            cmd: Command to execute
            operation_name: Name of the operation (for user messages)
            initial_timeout: Initial timeout in seconds
        Returns:
            subprocess.CompletedProcess result
        """
        current_timeout = initial_timeout
        
        while True:
            try:
                return subprocess.run(cmd, capture_output=True, text=True, timeout=current_timeout)
            except subprocess.TimeoutExpired:
                print(f"\n[!] WARNING: {operation_name} operation timed out after {current_timeout//60} minutes!")
                print(f"[*] The {operation_name} operation is taking longer than expected.")
                print("[*] This could indicate very large app data or slow device/connection.")
                
                # Ask user if they want to continue
                try:
                    response = input("\n[?] Do you want to continue with additional time? (y/N/c): ").strip().lower()
                    
                    if response == 'y' or response == 'yes':
                        # Ask for additional minutes
                        try:
                            additional_minutes = input("[?] How many additional minutes? (1-30, default 10): ").strip()
                            if not additional_minutes:
                                additional_minutes = 10
                            else:
                                additional_minutes = int(additional_minutes)
                                if additional_minutes < 1 or additional_minutes > 30:
                                    print("[!] Invalid input. Using default 10 minutes.")
                                    additional_minutes = 10
                        except ValueError:
                            print("[!] Invalid input. Using default 10 minutes.")
                            additional_minutes = 10
                        
                        current_timeout = additional_minutes * 60
                        print(f"[*] Continuing {operation_name} operation with {additional_minutes} additional minutes...")
                        continue
                        
                    elif response == 'c' or response == 'cancel':
                        print(f"[!] {operation_name} operation cancelled by user.")
                        # Return a failed result
                        from types import SimpleNamespace
                        result = SimpleNamespace()
                        result.returncode = 1
                        result.stdout = ""
                        result.stderr = f"{operation_name} operation cancelled by user"
                        return result
                        
                    else:
                        print(f"[!] {operation_name} operation aborted - maximum time exceeded.")
                        # Raise the timeout exception to be handled by caller
                        raise subprocess.TimeoutExpired(cmd, current_timeout)
                        
                except KeyboardInterrupt:
                    print(f"\n[!] {operation_name} operation interrupted by user (Ctrl+C).")
                    # Return a failed result
                    from types import SimpleNamespace
                    result = SimpleNamespace()
                    result.returncode = 1
                    result.stdout = ""
                    result.stderr = f"{operation_name} operation interrupted by user"
                    return result

    def is_frida_server_running(self):
        """Check if Frida server is already running on the device."""
        if not self.adb_path or not self.device_id:
            return False
            
        try:
            # Method 1: Check processes
            ps_result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell",
                "ps | grep frida-server || ps -ef | grep frida-server"
            ], capture_output=True, text=True, timeout=10)
            
            if ps_result.stdout.strip():
                lines = ps_result.stdout.strip().split('\n')
                for line in lines:
                    if 'frida-server' in line and 'grep' not in line:
                        return True
            
            # Method 2: Check port listening
            port_result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell",
                "netstat -tuln 2>/dev/null | grep 27042 || ss -tuln 2>/dev/null | grep 27042"
            ], capture_output=True, text=True, timeout=10)
            
            if "27042" in port_result.stdout:
                return True
                
            return False
            
        except Exception:
            return False

    def setup_emulator_with_playstore_and_root(self):
        """Guide user through setting up an Android emulator with Play Store and root access"""
        print("\n" + "="*70)
        print("ðŸ¤– ANDROID EMULATOR SETUP - PLAY STORE + ROOT")
        print("="*70)
        
        print("\nðŸ“‹ RECOMMENDED SETUP STEPS:")
        print("-" * 50)
        print("1ï¸âƒ£  CREATE AVD WITH PLAY STORE:")
        print("   â€¢ Open Android Studio > Tools > AVD Manager")
        print("   â€¢ Create Virtual Device > Choose Pixel 6/7")
        print("   â€¢ Select system image with ðŸ›ï¸ Play Store icon")
        print("   â€¢ Use x86_64 architecture (faster performance)")
        print("   â€¢ Recommended: Android 11 (API 30) or 12 (API 31)")
        
        print("\n2ï¸âƒ£  START WITH ROOT ACCESS:")
        print("   â€¢ emulator -list-avds")
        print("   â€¢ emulator -avd <YOUR_AVD_NAME> -writable-system")
        
        print("\n3ï¸âƒ£  ENABLE ROOT:")
        print("   â€¢ adb root")
        print("   â€¢ adb remount")
        
        print("\n4ï¸âƒ£  VERIFY:")
        print("   â€¢ Use option 2 to check emulator status")
        print("   â€¢ Play Store should be in app drawer")
        
        # Check current status if emulator is running
        if self.adb_path and self.device_id:
            print("\n[*] Checking current emulator...")
            is_emulator, has_root, is_writable, msg = self.check_emulator_root_status()
            if is_emulator:
                playstore = self._check_playstore_availability()
                print("ðŸ¤– Emulator: âœ…")
                print(f"ðŸ” Root: {'âœ…' if has_root else 'âŒ'}")
                print(f"ðŸ“ Writable: {'âœ…' if is_writable else 'âŒ'}")
                print(f"ðŸ›ï¸ Play Store: {'âœ…' if playstore else 'âŒ'}")
                
                if has_root and is_writable and playstore:
                    print("\nðŸŽ‰ PERFECT! Your emulator is ready for pentesting!")
        
        return True

    def _check_playstore_availability(self):
        """Check if Google Play Store is available"""
        try:
            result = subprocess.run([
                self.adb_path, "-s", self.device_id, "shell",
                "pm list packages | grep com.android.vending"
            ], capture_output=True, text=True, timeout=10)
            return "com.android.vending" in result.stdout
        except:
            return False
